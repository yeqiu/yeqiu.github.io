<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cherrylover.github.io</id>
    <title>Jiang</title>
    <updated>2019-08-06T02:32:30.901Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cherrylover.github.io"/>
    <link rel="self" href="https://cherrylover.github.io/atom.xml"/>
    <subtitle>我允许你走进我的世界，但不许你在我的世界里走来走去。</subtitle>
    <logo>https://cherrylover.github.io/images/avatar.png</logo>
    <icon>https://cherrylover.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Jiang</rights>
    <entry>
        <title type="html"><![CDATA[[转] 目标方法前置检验模型设计与实现]]></title>
        <id>https://cherrylover.github.io/post/zhuan-biao-fang-fa-qian-zhi-jian-yan-mo-xing-she-ji-yu-shi-xian</id>
        <link href="https://cherrylover.github.io/post/zhuan-biao-fang-fa-qian-zhi-jian-yan-mo-xing-she-ji-yu-shi-xian">
        </link>
        <updated>2019-08-06T02:15:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转载自 <a href="https://feelschaotic.github.io/">feelschaotic 的个人博客</a></p>
</blockquote>
<h2 id="前言">前言</h2>
<p><a href="https://www.jianshu.com/p/ed880f35f97f">继上次的指纹验证</a>后，产品又提出了个项目典型需求：用户在未登录状态下，点击关注，跳转登录，登录成功后自动执行关注。</p>
<h2 id="分析">分析</h2>
<p>这里有两个需求：</p>
<ol>
<li>自动跳转到登录界面</li>
<li>登录成功后再自动执行关注行为</li>
</ol>
<p>思考下抽象出通用性，首先，我们的目的是执行关注行为，但是关注行为需要用户处于登录状态。也就是说执行某个操作时需要满足一些前提条件，而这些前提条件是需要用户参与才能满足。可能存在多个前提条件的需求，这里可以分离出目标行为和前提条件行为。</p>
<h2 id="技术选型">技术选型</h2>
<p>那就登录页面加个回调喽，登录成功就回调回去，不过，我们可不想在登录界面侵入太多逻辑代码，而且也违背了可维护性和通用性，难道以后扩展时，每个前置条件都要加回调？</p>
<p>再思考，第一想法是利用事件通知机制（EventBus、BroadcastReceiver），把登录成功这个事件 post 出去，异步执行关注行为。但如果前提条件有多个呢，是不是得发送多个事件？是不是得监听多个事件？而且，如果下次需求改了，目标事件不是执行关注事件了，而是执行发帖或者跳转到某个页面，那之前关注行为已经注册了，还是会通知到关注事件，难道要通过 msg 标志位来区分不同的目标行为吗？有没有更优雅简洁的方式呢？</p>
<p>再思考，如果用拦截器呢？</p>
<p>这种行为模式和拦截器非常相似，都是在执行目标前，判断是否符合条件。</p>
<p>但是拦截器似乎并不能直接完成我们的需求，因为我们需要插入一个验证行为后（例如进入登录界面），还要执行相应的操作，保证这个验证行为通过后，才能真正执行我们的目标行为。拦截器执行完后，马上会执行目标方法。中间并不会等待。所以我们根本没有办法去执行我们的登录操作，所以pass了。</p>
<p>那设计模式里的责任链模式，能不能提供点什么思路呢？</p>
<p>在责任链模式里，很多的处理对象由每一个对象对其下家的引用而联接起来形成一条链。请求在这个链上传递，直到链上的<strong>某一个</strong>对象决定处理此请求。<strong>注意，是某一个</strong>！而我们的场景是，需要通过<strong>所有的</strong>前置条件验证，才能执行目标方法。</p>
<h2 id="设计与实现">设计与实现</h2>
<p>思考可以改良一下责任链，每一个前置条件对象（<code>Valid</code>类）不再持有其下家的引用，而是采用一个队列存储所有的前置条件对象，以先进先出的顺序依次验证条件。</p>
<pre><code class="language-java">private Queue&lt;Valid&gt; validQueue = new ArrayDeque&lt;&gt;();
</code></pre>
<p>前置条件对象抽象为接口<code>Valid</code></p>
<pre><code class="language-java">public interface Valid {
    /**
     * 是否满足检验器的要求，如果不满足的话，则执行doValid()方法。如果满足，则执行目标action.call
     * @return
     */
    boolean preCheck();

    /**
     * 去执行验证前置行为，例如跳转到登录界面。（但并未完成验证。所以需要在登陆成功时调用preCheck()再次检查）
     */
    void doValid();

}
</code></pre>
<p>可以看到，我们把前置条件对象的验证条件和操作分离开来。</p>
<p>目标对象<code>Action</code>就很简单了，仅拥有一个目标执行方法。</p>
<pre><code class="language-java">public interface Action {
    void call();
}
</code></pre>
<p>整体的验证流程，如下图所示：</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/delay-action/delay_action_process.png" alt="验证流程"></p>
<p>循环从前置条件对象队列 <code>validQueue</code> 里取出验证对象，调用 check 方法判断是否满足条件，不满足则进入该验证对象的验证流程，验证完毕，再次调用 check 方法判断满足条件，如果满足则取下一个，直至队列为空，就可以直接执行目标方法了。</p>
<p>那么前置条件对象队列 <code>validQueue</code> 和目标对象的持有方，我们封装为 <code>Call</code>，意为一次执行。</p>
<pre><code class="language-java">public class Call {
    //目标对象 
    private Action action;
    //先进先出验证模型
    private Queue&lt;Valid&gt; validQueue = new ArrayDeque&lt;&gt;();
    //上一个执行的valid
    private Valid lastValid;

}
</code></pre>
<p>包装一个单例的持有Call对象的外观类 <code>SingleCall</code>，提供给业务层调用。</p>
<pre><code class="language-java">public class SingleCall {

    private Call call = new Call();

    public SingleCall addAction(Action action) {
        clear();
        call.setAction(action);
        return this;
    }

    public SingleCall addValid(Valid valid) {
        //只添加无效的，验证不通过的
        if (valid.preCheck()) {
            return this;
        }
        call.addValid(valid);
        return this;
    }

    public void doCall() {
        //如果上一条valid没有通过，是不允许再发起call的
        if (call.getLastValid() != null &amp;&amp; !call.getLastValid().preCheck()) {
            return;
        }

        //如果全部都验证通过了，执行action
        if (call.getValidQueue().size() == 0) {
            if (call.getAction() != null) { //容错处理
                call.getAction().call();
                clear();
            }
        } else {
            //执行验证
            Valid valid = call.getValidQueue().poll();
            call.setLastValid(valid);
            valid.doValid();
        }

    }
    .....
}
</code></pre>
<p>调用示例（常用场景，单 Action）：</p>
<p><code>Activity</code> 实现 <code>Action</code> 接口，或 new 一个<code>Action</code> 实现类，实现 call 目标行为。</p>
<p>前置行为完成后，调用 <code>SingleCall.getInstance().doCall();</code> 重新启动验证模型。因为验证操作需要用户手动触发完成，我们只是引导用户到了验证体里，由于我们因为等待用户的操作，验证模型就在这里停下来了，如果验证操作成功了，我们需要让整个验证模型再运转起来了，所以验证后，永远少不了手动开启验证模型。</p>
<p>以下是整个模型的类 UML 图，重点梳理 Valid、Call、Action 三者的关系：</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/delay-action/delay_action_uml.png" alt="类 UML 图"></p>
<h2 id="应用场景">应用场景</h2>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/delay-action/delay_action_since.png" alt=""></p>
<h2 id="源码地址">源码地址</h2>
<p><a href="https://github.com/feelschaotic/DelayAction">github 源码地址</a></p>
<ul>
<li>增加了容错处理</li>
<li>补充了嵌套 Call 的情况</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/22a9d4eb07ce">在执行目标操作前，插入N个需要用户参与的操作，简化此过程</a></li>
<li><a href="https://www.jianshu.com/p/1d0180ec64fb">android 登录成功后再跳转到目标界面的思考</a></li>
</ul>
</blockquote>
<p>本文转载自 <a href="https://feelschaotic.github.io/">feelschaotic 的个人博客</a>，封面图是编者加的，封面图：Photo by <a href="https://unsplash.com/@chengfengrecord?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">cheng feng</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Navigation 之 Fragment 切换]]></title>
        <id>https://cherrylover.github.io/post/navigation-zhi-fragment-qie-huan</id>
        <link href="https://cherrylover.github.io/post/navigation-zhi-fragment-qie-huan">
        </link>
        <updated>2019-07-24T07:13:43.000Z</updated>
        <content type="html"><![CDATA[<p>本篇是有关 Navigation 的第二篇，如有对 Navigation 不了解的朋友请先阅读<a href="https://jiangjiwei.site/post/lai-xue-yi-bo-navigation/">来学一波 Navigation</a>。</p>
<p>在上一篇中，我们利用 Navigation 与 BottomNavigationView 做出了一个有三个 Tab 的页面，分别是 Feed、Timer、Mine，这三个 Fragment 都是只在当前页面显示各自的名称。</p>
<p>现在我们来给 TimerFragment 加点内容，我们在 TimerFragment 的 onCreateView 方法中启动一个倒计时。</p>
<pre><code class="language-java">private void startTimer() {
    new CountDownTimer(10 * 1000, 1000) {

        @Override
        public void onTick(long millisUntilFinished) {
            tvLabel.setText(String.valueOf((millisUntilFinished / 1000) + 1));
        }

        @Override
        public void onFinish() {
            tvLabel.setText(&quot;Finished&quot;);
        }
    }.start();
}
</code></pre>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/blog_nav_tab.gif" alt=""></p>
<p>仔细看上面的效果可以看到，每次切换到 TimerFragment 时，倒计时总会重新开始，不是我们想要的仅开始一次。这是什么问题导致的呢？答案是 TimerFragment 执行了多次的 onCreateView，为什么是会执行多次，Fragment 为什么会加载多次？我们没有什么特殊的操作呀。是不是因为 Navigation？</p>
<p>现在让我们深入到 Navigation 的源码看一看这到底是怎么一回事，以及我们改如何解决这一问题。</p>
<p>首先，我们需要明确我们的方向，就是 Navigation 到底是怎么做 Fragment 切换的，为什么会导致 Fragment 的 onCreateView 被多次执行。</p>
<p>从哪里作为入口呢？了解过 Navigation 的朋友对下面这行代码应该不会陌生，就是通过一个 View 获取到 NavController，然后通过执行 NavController 的 navigate 这个方法，我们就从这个方法开始。</p>
<pre><code class="language-java">Navigation.findNavController(view)
        .navigate(id);
</code></pre>
<p>这个 navigate 有多个重载方法，我们开始的 navigate 方法最终也是执行到下面这个重载方法。</p>
<pre><code class="language-java">navigate(NavDestination node, Bundle args, NavOptions navOptions, Navigator.Extras navigatorExtras)
</code></pre>
<p>方法的具体内容如下图：</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/blog_code_navigate.png" alt=""></p>
<p>其中在第 9 行，我们可以看到通过 mNavigatorProvider 获取到了一个泛型类型为 NavDestination 的 Navigator 对象，并且在第 12 行时，通过调用刚获取到的 navigator 的 navigate 方法，得到了 NavDestination 这个对象。</p>
<p>这两行是关键代码，一个是获取到执行 navigate 的对象，一个是实际执行 navigate 的方法。看到这，我们就只需要找到 Navigator 的 navigate 方法即可。不过，Navigator 这个只是一个抽象类，我们还需要继续寻找它的实现类。</p>
<blockquote>
<p>快捷键：Implementation(s) Mac: option(⌥) + command(⌘)+B</p>
</blockquote>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/image-20190724110340568.png" alt="image-20190724110340568"></p>
<p>Navigator 抽象类的关键代码：</p>
<pre><code class="language-java">public abstract class Navigator&lt;D extends NavDestination&gt; {
    @Retention(RUNTIME)
    @Target({TYPE})
    @SuppressWarnings(&quot;UnknownNullness&quot;)
    public @interface Name {
        String value();
    }

    @NonNull
    public abstract D createDestination();

    @Nullable
    public abstract NavDestination navigate(@NonNull D destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Extras navigatorExtras);

    public abstract boolean popBackStack();

    @Nullable
    public Bundle onSaveState() {
        return null;
    }

    public void onRestoreState(@NonNull Bundle savedState) {
    }

    public interface Extras {
    }
}
</code></pre>
<p>通过快捷键我们能找到多个实现类，有 ActivityNavigator、DialogFragmentNavigator 还有 FragmentNavigator 等，这里我们只关注 FragmentNavigator 这个类中的 navigate 这个方法。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/blog_code_navigate_real.png" alt=""></p>
<p>别看这么多代码，别害怕，其实关键部分的代码就是第 32 行 <code>ft.replace(mContainerId, frag)</code> 这里使用的是 FragmentTransaction 的 replace 方法，这个方法不用说了吧。 replace 是移除了相同 id 的 fragment 然后再进行 add 的。</p>
<p>所以，看到这，我们也就知道了，为什么 TimerFragment 的 onCreateView 方法会被执行多次了，原因就是在这。</p>
<p>找到原因了，那我们有什么方法去规避，或者说去绕过这个 replace 吗？答案是有的。</p>
<p>还记得刚才我们找的下面这行代码吧（忘记的，请看第一张代码图的第 9 行），刚才我说，通过 mNavigatorProvider 找到一个泛型类型为 NavDestination 的 Navigator 对象，那它实际上是怎么找到的呢？是通过 node.getNavigatorName() 然后找的，这个 node 是什么东西？以及 mNavigatorProvider.getNavigator 内部究竟发生了什么？</p>
<pre><code class="language-java">Navigator&lt;NavDestination&gt; navigator = mNavigatorProvider.getNavigator(
        node.getNavigatorName());
</code></pre>
<p>实际上这里的 node 就是一个 NavDestination 对象，而一个 NavDestination 对象就是对应着 navigation graph 中的节点信息。我用来演示的 Demo 的 navigation graph 文件如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/tab_navigation&quot;
    app:startDestination=&quot;@id/feedFragment&quot;&gt;

    &lt;fragment
        android:id=&quot;@+id/feedFragment&quot;
        android:name=&quot;me.monster.blogtest.tab.FeedFragment&quot;
        android:label=&quot;fragment_feed&quot;
        tools:layout=&quot;@layout/fragment_feed&quot; /&gt;
    &lt;fragment
        android:id=&quot;@+id/timerFragment&quot;
        android:name=&quot;me.monster.blogtest.tab.TimerFragment&quot;
        android:label=&quot;fragment_timer&quot;
        tools:layout=&quot;@layout/fragment_timer&quot; /&gt;
    &lt;fragment
        android:id=&quot;@+id/mineFragment&quot;
        android:name=&quot;me.monster.blogtest.tab.MineFragment&quot;
        android:label=&quot;fragment_mine&quot;
        tools:layout=&quot;@layout/fragment_mine&quot; /&gt;
&lt;/navigation&gt;
</code></pre>
<p>node.getNavigatorName 返回的就是 fragment 节点的节点名称 <code>fragment</code>，而 getNavigator 其实内部就是维护了一个类型为 HashMap 的 mNavigators，这个 HashMap 存的 key 就是节点名称，value 就是抽象类 Navigator 的实现类。而 fragment 对应的 FragmentNavigator 也存储在其中。</p>
<p>既然是存在一个 map，并从中取出相对于的 Navigator 实现类，那我们能不能创建一个类并实现 Navigator，然后将 key、value 添加到那个 HashMap 中。答案是可行的。在NavigatorProvider 这个类中有两个公共方法：</p>
<ul>
<li>addNavigator(Navigator navigator)</li>
<li>addNavigator(String name, Navigator navigator)</li>
</ul>
<p>其中，一个参数的 addNavigator 也是调用了 两个参数的 addNavigator 方法，那个 name 也就是 navigation graph 中 fragment 节点的节点名称，同时也是 Navigator 这个抽象类中注解 <code>Name</code> 定义的值。而且在 NavController 这个类（最初我们找到的 navigate 所在的类）中有一个 getNavigatorProvider() 方法。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/uml_blog_navigation.jpg" alt=""></p>
<p>看到这，关系应该就比较清楚了。所以，我们需要自己创建一个类，实现 Navigator 并未 Name 注解添加一个值，然后在使用 Navigation 这个模块的 Activity 获取到 NavController 并调用其 getNavigatorProvider 方法后再调用 addNavigator 即可。</p>
<p>Github 上已经有一个演示自定义实现 Navigator 的项目了。这个项目是以 Kotlin 语言编写的。</p>
<p>项目地址： https://github.com/STAR-ZERO/navigation-keep-fragment-sample。</p>
<blockquote>
<p>说起来这个项目还是 <a href="https://github.com/drakeet">Drakeet</a> 在他的知识星球中分享的。感谢 Drakeet 的分享。</p>
</blockquote>
<p>我根据按照他的代码写了一份 Java 版本的，并且在其中改了两行代码（注释部分）。注释的内容其实就是使用 FragmentTranslation 对 Fragment 进行控制。原作者写的是 detach 与 attach 方法，我改成了使用 hide 和 show 方法。</p>
<pre><code class="language-java">@Navigator.Name(&quot;keep_state_fragment&quot;)
public class KeepStateNavigator extends FragmentNavigator {
    private Context context;
    private FragmentManager manager;
    private int containerId;

    public KeepStateNavigator(@NonNull Context context, @NonNull FragmentManager manager, int containerId) {
        super(context, manager, containerId);
        this.context = context;
        this.manager = manager;
        this.containerId = containerId;
    }

    @Nullable
    @Override
    public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
        String tag = String.valueOf(destination.getId());
        FragmentTransaction transaction = manager.beginTransaction();
        boolean initialNavigate = false;
        Fragment currentFragment = manager.getPrimaryNavigationFragment();
        if (currentFragment != null) {
//            transaction.detach(currentFragment);
            transaction.hide(currentFragment);
        } else {
            initialNavigate = true;
        }
        Fragment fragment = manager.findFragmentByTag(tag);
        if (fragment == null) {
            String className = destination.getClassName();
            fragment = manager.getFragmentFactory().instantiate(context.getClassLoader(), className);
            transaction.add(containerId, fragment, tag);
        } else {
//            transaction.attach(fragment);
            transaction.show(fragment);
        }

        transaction.setPrimaryNavigationFragment(fragment);
        transaction.setReorderingAllowed(true);
        transaction.commitNow();
        return initialNavigate ? destination : null;
    }
}
</code></pre>
<p>注意，使用自定义 Navigator 的时候 navigation graph 需要把 fragment 节点名称改为 keep_state_fragment，并且在承载的 Activity 中进行设置并且还需要把 Activity 布局文件中 fragment 的 navGraph 属性移除。</p>
<pre><code class="language-java">NavController navController = Navigation.findNavController(this, R.id.fragment3);
NavHostFragment navHostFragment = (NavHostFragment) getSupportFragmentManager().findFragmentById(R.id.fragment3);
KeepStateNavigator navigator = new KeepStateNavigator(this, navHostFragment.getChildFragmentManager(), R.id.fragment3);
navController.getNavigatorProvider().addNavigator(navigator);
navController.setGraph(R.navigation.tab_navigation);
</code></pre>
<p>最后来看一下使用自定义 Navigator 时的 TabActivity。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/blog_nav_tab_state.gif" alt=""></p>
<p>本文首发于<a href="https://jiangjiwei.site/">个人博客</a>，文中全部源代码已上传至 <a href="https://github.com/CherryLover/BlogTest">GitHub</a>，代码分支为 master。喜欢本文的麻烦点个🌟。</p>
<p>本文封面图：Photo by <a href="https://unsplash.com/@joaosilas?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">João Silas</a> on <a href="https://unsplash.com/search/photos/translation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[看一看 DataBinding]]></title>
        <id>https://cherrylover.github.io/post/kan-yi-kan-databinding</id>
        <link href="https://cherrylover.github.io/post/kan-yi-kan-databinding">
        </link>
        <updated>2019-07-23T05:08:48.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在看一些人写的代码，发现很多都有用到 DataBinding，每每看到 DataBinding 相关的代码看不懂，摸不透，实在是难受啊，可是怎么办呢，谁让自己不会的呢。没办法开始学吧，不要求会太多，总得能看的懂人家写的是啥意思吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在看一些人写的代码，发现很多都有用到 DataBinding，每每看到 DataBinding 相关的代码看不懂，摸不透，实在是难受啊，可是怎么办呢，谁让自己不会的呢。没办法开始学吧，不要求会太多，总得能看的懂人家写的是啥意思吧。</p>
<!-- more -->
<blockquote>
<p>本篇难度属于 DataBinding 入门级别，如果有什么错误，还请指正。要学习 DataBinding 最好的教材还是通过官方给的<a href="https://codelabs.developers.google.com/codelabs/android-databinding/#0">实例教程</a>。</p>
</blockquote>
<p>正式开始之前呢，总是得添加依赖，不过，DataBinding 的依赖可不像 RxJava 或是其他库通过引入两行依赖，而是通过在 app.gradle 文件中引入下面的配置：</p>
<pre><code class="language-groovy">android {
    ...
    dataBinding {
        enabled = true
    }
}
</code></pre>
<p>有了依赖之后，我们就可以开始了，现在想象一个场景，我们需要把一段文字显示在 TextView 上。之前，我们都是通过 findViewById，然后 setText，现如今来一起看看 DataBinding 是怎么做的吧。</p>
<p>首先，我们需要把布局文件的结构进行改造一下，改造成这样的结构。</p>
<pre><code class="language-xml">&lt;layout&gt;
    &lt;data&gt;
    &lt;/data&gt;
    &lt;ViewGroup&gt;
    &lt;/ViewGroup&gt;
&lt;/layout&gt;
</code></pre>
<blockquote>
<p>Android Studio 对 DataBinding 有自动替换的支持。</p>
</blockquote>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/image-20190718101219778.png" alt="image-20190718101219778"></p>
<p>替换之后的 ViewGroup 就是之前的根布局，data 节点内用于定义数据。</p>
<pre><code class="language-xml">&lt;data&gt;
    &lt;variable name=&quot;content&quot; type=&quot;String&quot; /&gt;
&lt;/data&gt;
</code></pre>
<p>以此形式定义的变量 content 等价于 <code>String content</code>。拿到了 content 这个变量，紧接着就需要设置到 TextView 上。设置 Text，使用的属性是 <code>android:text=&quot;&quot;</code> 至于填入的值，就是 content，不过语法上稍有不同，<code>android:text=&quot;@{content}&quot;</code> 其中 <code>@</code> 以及<code>{}</code>是用于包裹其中的值，以此来区分开 <code>android:text=&quot;content&quot;</code>。</p>
<blockquote>
<p>Databinding 使用这种语法来设置内容，事实上这种表达方法不仅仅用于设置个字符串，还支持表达式，更多内容请参<a href="https://developer.android.com/topic/libraries/data-binding/expressions">考官方文档</a>。本文也会介绍一些。</p>
</blockquote>
<p>事实上，我们更多时候会把 content 作为一个类的成员变量。只要将 variable 的 type 属性改成对应的类名，同时在 TextView 上改为 <code>android:text=&quot;@{detail.content}&quot;</code> 即可。</p>
<pre><code class="language-xml">&lt;data&gt;
    &lt;variable name=&quot;detail&quot; type=&quot;me.monster.blogtest.model.MomentDetail&quot; /&gt;
&lt;/data&gt;
</code></pre>
<p>在布局文件中定义好了变量，现在我们该回到 Java 文件中将布局文件使用 DataBinding 进行绑定上数据了。</p>
<pre><code class="language-java">public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,
                             @Nullable Bundle savedInstanceState) {
        FragmentDetailBinding viewDataBinding = DataBindingUtil.inflate(inflater, R.layout.fragment_detail, container, false);
        View root = viewDataBinding.getRoot();
        mMomentDetail = new MomentDetail();
  			mMomentDetail.setContent(&quot;使用 DataBinding&quot;);
        viewDataBinding.setDetail(mMomentDetail);
        return root;
    }
</code></pre>
<blockquote>
<ol>
<li>这段代码是使用在 Fragment 中的，如果在 Activity 中，则使用 <code>DataBinding.Util.setContentView(Activity activity, int layoutId)</code> 这个方法。</li>
<li>FragmentDetailBinding 这个类是根据布局文件生成的，类名的规则是布局文件的文件名+Binding；</li>
</ol>
</blockquote>
<p>DataBinding 这样使用，好像不太够日常使用。当 mMomentDetail 内部的 content 发生改变时，TextView 能自动更新吗？暂时不行，想让 TextView 自动更新 mMomentDetail 的 content 的内容，我们还需要另外的一些东西。</p>
<p>要想及时更新 mMomentDetail 的 content 内容，按照以往的做法，就是在更新 mMomentDetail 的 content 内容时，手动调用 <code>setText()</code> 这个方法。现在有了 DataBinding 就不用了。我们可以把 mMomentDetail 的 content 定义为一种可观察其变化的类型，然后通过 DataBinding 就能自动完成对 TextView 上内容的更新。</p>
<pre><code class="language-java">public class MomentDetail {    
    private String content;

    public String getContent() {
        return content == null ? &quot;&quot; : content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}
</code></pre>
<p>这个是 TextView 不能自动更新内容的 MomentDetail 类，要想让 TextView 自动更新，只需要把 content 的类型改变即可。改为 <code>ObservableField&lt;String&gt; content</code>。</p>
<pre><code class="language-java">private ObservableField&lt;String&gt; content = new ObservableField&lt;&gt;();

public ObservableField&lt;String&gt; getContent() {
    return content;
}

public String getContentValue() {
    return content.get();
}

public void setContent(String content) {
    this.content.set(content);
}
</code></pre>
<p>与普通的 String 类型不同的是，想要改变 content 的值，需要调用 <code>ObservableField.set(T t)</code> 方法，获取其中的值则使用 <code>ObservableField.get()</code> 方法。</p>
<p>DataBinding 还包含了一些其他的类，都是一样的用法。</p>
<ul>
<li>ObservableBoolean</li>
<li>ObservableByte</li>
<li>ObservableChar</li>
<li>ObservableShort</li>
<li>ObservableInt</li>
<li>ObservableLong</li>
<li>ObservableFloat</li>
<li>ObservableDouble</li>
<li>ObservableParcelable</li>
</ul>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/blog_databinding_observable.gif" alt=""></p>
<blockquote>
<p>我在写这篇博客的时候，使用 Handler 延迟几秒钟对 MomentDetail 进行修改，用于模拟点击事件。</p>
</blockquote>
<p>当我们用于观察的数据较多的时候，还可以通过将自定义的数据类继承 BaseObservable ，产生继承关系之后，数据类中的成员变量均可以在发生改变时自动应用到 View 上。</p>
<pre><code class="language-java">public class MomentDetail extends BaseObservable {
    private String moment;
    private int goodCount;

    @Bindable
    public String getMoment() {
        return moment == null ? &quot;&quot; : moment;
    }

    @Bindable
    public int getGoodCount() {
        return goodCount;
    }

    public void setContent(String msg) {
        this.moment = msg;
        notifyPropertyChanged(BR.moment);
    }

    public void updateGood(int count) {
        goodCount = count;
        notifyPropertyChanged(BR.goodCount);
    }
}
</code></pre>
<p>跟其他的数据类没有什么太大的差距，只是多了一个注解 <code>@Bindable</code> 以及在成员变量进行更改后进行更新 <code>notifyPropertyChanged()</code>。不过，Google 还是推荐使用 LiveData 配合使用。</p>
<pre><code class="language-java">public class MomentViewModel extends ViewModel {

    private MutableLiveData&lt;String&gt; name = new MutableLiveData&lt;&gt;(&quot;Abs&quot;);
    private MutableLiveData&lt;Integer&gt; good = new MutableLiveData&lt;&gt;();

    public void setNameValue(String value) {
        name.setValue(value);
    }

    public MutableLiveData&lt;String&gt; getName() {
        return name;
    }

    public MutableLiveData&lt;Integer&gt; getGood() {
        return good;
    }

    public void setGoodValue(int goodValue) {
        good.setValue(goodValue);
    }
}
</code></pre>
<p>相应的，布局文件中也要进行更改数据类型。</p>
<pre><code class="language-xml">&lt;variable
    name=&quot;viewModel&quot;
    type=&quot;me.monster.blogtest.model.MomentViewModel&quot; /&gt;
</code></pre>
<p>DataBinding 设置 View 的 <code>text</code>，<code>textColor</code> 等属性都可以直接通过类似 <code>android:text=&quot;@{viewModel.name}&quot;</code> 这种形式来进行操作，那如果想对控件进行点击事件的监听怎么办呢？也不麻烦，我们只需要提供一个用于处理点击结果的方法即可。</p>
<p>例如，我们有一个 TextView 用于进行点击，并将点击次数显示在当前 TextView 上。</p>
<pre><code class="language-java">public void upGood() {
    good.setValue(good.getValue() == null ? 1 : good.getValue() + 1);
}
</code></pre>
<pre><code class="language-xml">&lt;TextView
    android:id=&quot;@+id/iv_good&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;40dp&quot;
    android:drawableStart=&quot;@drawable/ic_good&quot;
    android:drawablePadding=&quot;8dp&quot;
    android:gravity=&quot;center&quot;
    android:onClick=&quot;@{() -&gt; viewModel.upGood()}&quot;
    android:text=&quot;@{String.valueOf(viewModel.good)}&quot; /&gt;
</code></pre>
<p>不过，DataBinding 虽然挺好的，但是还是有些不足，比如通过 Glide 这种第三方框架加载图片，还是得 <code>findViewById</code>，事实上，DataBinding 提供了另一种解决思路，通过将一个静态方法加上注解，然后就可以在 View 中进行使用。</p>
<pre><code class="language-java">@BindingAdapter({&quot;imageRes&quot;})
public static void loadImage(ImageView imageView, int resId) {
    Glide.with(imageView)
            .load(resId)
            .into(imageView);
}
</code></pre>
<pre><code class="language-xml">&lt;ImageView
    android:id=&quot;@+id/iv_avatar&quot;
    imageRes=&quot;@{viewModel.avatar}&quot;
    android:layout_width=&quot;50dp&quot;
    android:layout_height=&quot;50dp&quot;
    android:src=&quot;@mipmap/avatar_1&quot; /&gt;
</code></pre>
<blockquote>
<p>BindAdapter 还有更多其他用法，请<a href="https://developer.android.com/topic/libraries/data-binding/binding-adapters">参考官方文档</a>。</p>
</blockquote>
<p>整体来说，DataBinding 不难，而且入门也挺简单的，不过，刚上手，很多时候摸不到头脑。不过，它的好处也很明显，在 Fragment 或是 Activity 中没有使用任何直接或是间接的 <code>findViewById</code> 操作。保证了 Activity 与 Fragment 的简洁，使其能更好的专注于页面的跳转及数据的处理，倘若配合着 Jetpack 的其他组件协同开发，估计会更高效些。</p>
<p>本文旨在学习如何简单的使用 DataBinding，主体内容较为简单，实际上，日常开发中还会经常用到 RecyclerView 及其他功能，DataBinding 也能提供很好的支持，有兴趣或是需要的话可以自行查阅<a href="https://developer.android.com/topic/libraries/data-binding">官方文档</a>。</p>
<p>文章首发于<a href="https://jiangjiwei.site">个人博客</a>，文中所有代码均已上传至 <a href="https://github.com/CherryLover/BlogTest">GitHub</a>，代码分支为：dataBinding。</p>
<p>相关文章推荐：</p>
<ul>
<li><a href="https://jiangjiwei.site/post/yong-motionlayout-lai-zuo-guo-du-dong-hua/">用 MotionLayout 来做过渡动画</a></li>
<li><a href="https://jiangjiwei.site/post/lai-xue-yi-bo-navigation/">来学一波 Navigation</a></li>
</ul>
<p>本文封面图：Photo by <a href="https://unsplash.com/@paul__schafer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Paul Schafer</a> on <a href="https://unsplash.com/search/photos/learn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 混淆]]></title>
        <id>https://cherrylover.github.io/post/android-hun-yao</id>
        <link href="https://cherrylover.github.io/post/android-hun-yao">
        </link>
        <updated>2019-07-15T15:40:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本篇文章的主要内容是本人在学习 Android 混淆时觉得不错的文章。特地收藏过来，原文链接：https://www.diycode.cc/topics/380。</p>
</blockquote>
<p>一直以来知道 Android 混淆，但是都没上手用过，大概，好像知道点东西，但又搞不清，干脆来好好学一下。</p>
<p>我们说混淆一般都是说在 ProGuard 文件中我们定义的内容，那定义在 ProGuard 内容有什么作用呢？我问了一些人，得到了下面几个答案，来看看吧。</p>
<ol>
<li>能够在编译时修改源代码使其难以被阅读而且能够做代码压缩；</li>
<li>检测和移除封装应用中未使用的类、字段、方法和属性，包括第三方代码库中的未使用项（这使其成为以变通方式解决 64k 引用限制的有用工具）；</li>
<li>优化字节码，移除未使用的代码指令；</li>
<li>用短名称混淆其余的类、字段和方法；</li>
<li>混淆过的代码可令 APK 难以被逆向工程；</li>
<li>APK 能够被压缩，而且压缩的幅度较大，能帮助你的应用更容易被用户接收。同时，APK 体积也会影响安装和冷启动速度，越大越慢。</li>
</ol>
<p>看到这点多优点，我实在按捺不住了，于是我开始新的征途，下面正文开始。</p>
<h2 id="写在前面">写在前面</h2>
<p>大家好，我是光源。</p>
<p>本文首发于我的个人公众账号，同时会在个人博客上同步。如果博客本身有修改或勘误，会在博客更新。</p>
<h2 id="综述">综述</h2>
<p>毫无疑问，混淆是打包过程中最重要的流程之一，在没有特殊原因的情况下，所有 app 都应该开启混淆。</p>
<p>首先，这里说的的混淆其实是包括了代码压缩、代码混淆以及资源压缩等的优化过程。依靠 ProGuard，混淆流程将主项目以及依赖库中未被使用的类、类成员、方法、属性移除，这有助于规避64K方法数的瓶颈；同时，将类、类成员、方法重命名为无意义的简短名称，增加了逆向工程的难度。而依靠 Gradle 的 Android 插件，我们将移除未被使用的资源，可以有效减小 apk 安装包大小。</p>
<p>本文由两部分构成，第一部分给出混淆的最佳实践，力求让零基础的新手都可以直接使用混淆；第二部分会介绍一下混淆的整体、自定义混淆规则的语法与实践、自定义资源保持的规则等。</p>
<h2 id="一-android混淆最佳实践">一、Android混淆最佳实践</h2>
<h3 id="1-混淆配置">1. 混淆配置</h3>
<p>一般情况下，app module 的 <code>build.gradle</code> 文件默认会有如下结构：</p>
<pre><code>android {
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
</code></pre>
<p>因为开启混淆会使编译时间变长，所以<code>debug</code>模式下不应该开启。我们需要做的是：</p>
<ol>
<li>将<code>release</code>下<code>minifyEnabled</code>的值改为<code>true</code>，打开混淆；</li>
<li>加上<code>shrinkResources true</code>，打开资源压缩。</li>
</ol>
<p>修改后文件内容如下：</p>
<pre><code>android {
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
</code></pre>
<h3 id="2-自定义混淆规则">2. 自定义混淆规则</h3>
<p>在 <code>app module</code> 下默认生成了项目的自定义混淆规则文件 <code>proguard-rules.pro</code>，多方调研后，一份适用于大部分项目的混淆规则最佳实践如下：</p>
<pre><code>#指定压缩级别
-optimizationpasses 5

#不跳过非公共的库的类成员
-dontskipnonpubliclibraryclassmembers

#混淆时采用的算法
-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*

#把混淆类中的方法名也混淆了
-useuniqueclassmembernames

#优化时允许访问并修改有修饰符的类和类的成员 
-allowaccessmodification

#将文件来源重命名为“SourceFile”字符串
-renamesourcefileattribute SourceFile
#保留行号
-keepattributes SourceFile,LineNumberTable

#保持所有实现 Serializable 接口的类成员
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

#Fragment不需要在AndroidManifest.xml中注册，需要额外保护下
-keep public class * extends android.support.v4.app.Fragment
-keep public class * extends android.app.Fragment

# 保持测试相关的代码
-dontnote junit.framework.**
-dontnote junit.runner.**
-dontwarn android.test.**
-dontwarn android.support.test.**
-dontwarn org.junit.**
</code></pre>
<p>真正通用的、需要添加的就是上面这些，除此之外，需要每个项目根据自身的需求添加一些混淆规则：</p>
<ul>
<li>第三方库所需的混淆规则。正规的第三方库一般都会在接入文档中写好所需混淆规则，使用时注意添加。</li>
<li>在运行时动态改变的代码，例如反射。比较典型的例子就是会与 json 相互转换的实体类。假如项目命名规范要求实体类都要放在model包下的话，可以添加类似这样的代码把所有实体类都保持住：-keep public class <strong>.<em>Model</em>.</strong> {*;}<br>
- JNI中调用的类。<br>
- WebView中JavaScript调用的方法<br>
- Layout布局使用的View构造函数、android:onClick等。</li>
</ul>
<h3 id="3-检查混淆结果">3. 检查混淆结果</h3>
<p>混淆过的包必须进行检查，避免因混淆引入的bug。</p>
<p>一方面，需要从代码层面检查。使用上文的配置进行混淆打包后在 <module-name>/build/outputs/mapping/release/ 目录下会输出以下文件：<br>
- dump.txt <br>
描述APK文件中所有类的内部结构<br>
- mapping.txt<br>
提供混淆前后类、方法、类成员等的对照表<br>
- seeds.txt<br>
列出没有被混淆的类和成员<br>
- usage.txt<br>
列出被移除的代码</p>
<p>我们可以根据 <code>seeds.txt</code> 文件检查未被混淆的类和成员中是否已包含所有期望保留的，再根据 <code>usage.txt</code> 文件查看是否有被误移除的代码。</p>
<p>另一方面，需要从测试方面检查。将混淆过的包进行全方面测试，检查是否有 bug 产生。</p>
<h3 id="4-解出混淆栈">4. 解出混淆栈</h3>
<p>混淆后的类、方法名等等难以阅读，这固然会增加逆向工程的难度，但对追踪线上 crash 也造成了阻碍。我们拿到 crash 的堆栈信息后会发现很难定位，这时需要将混淆反解。</p>
<p>在 <code>&lt;sdk-root&gt;/tools/proguard/</code> 路径下有附带的的反解工具（Window 系统为 <code>proguardgui.bat</code>，Mac 或 Linux 系统为 <code>proguardgui.sh</code>）。</p>
<p>这里以 Window 平台为例。双击运行 <code>proguardgui.bat</code> 后，可以看到左侧的一行菜单。点击 <code>ReTrace</code>，选择该混淆包对应的 mapping 文件（混淆后在 <code>&lt;module-name&gt;/build/outputs/mapping/release/</code> 路径下会生成 <code>mapping.txt</code> 文件，它的作用是提供混淆前后类、方法、类成员等的对照表），再将 crash 的 <code>stack trace</code> 黏贴进输入框中，点击右下角的 <code>ReTrace</code> ，混淆后的堆栈信息就显示出来了。</p>
<p>以上使用 GUI 程序进行操作，另一种方式是利用该路径下的 <code>retrace</code> 工具通过命令行进行反解，命令是</p>
<pre><code class="language-shell">retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;]
</code></pre>
<p>例如：</p>
<pre><code class="language-shell">retrace.bat -verbose mapping.txt obfuscated_trace.txt
</code></pre>
<h3 id="注意事项">注意事项：</h3>
<ol>
<li>
<p>所有在 <code>AndroidManifest.xml</code> 涉及到的类已经自动被保持，因此不用特意去添加这块混淆规则。（很多老的混淆文件里会加，现在已经没必要）</p>
</li>
<li>
<p><code>proguard-android.txt</code> 已经存在一些默认混淆规则，没必要在 <code>proguard-rules.pro</code> 重复添加，该文件具体规则见附录1：</p>
</li>
</ol>
<h2 id="二-混淆简介">二、混淆简介</h2>
<p>Android中的“混淆”可以分为两部分，一部分是 Java 代码的优化与混淆，依靠 proguard 混淆器来实现；另一部分是资源压缩，将移除项目及依赖的库中未被使用的资源(资源压缩严格意义上跟混淆没啥关系，但一般我们都会放一起讲)。</p>
<h3 id="1-代码压缩">1. 代码压缩</h3>
<p><a href="http://zhenghuiy-blog.qiniudn.com/proguard-process.png"><img src="http://zhenghuiy-blog.qiniudn.com/proguard-process.png" alt="img"></a></p>
<p>代码混淆是包含了代码压缩、优化、混淆等一系列行为的过程。如上图所示，混淆过程会有如下几个功能：</p>
<ol>
<li>压缩。移除无效的类、类成员、方法、属性等；</li>
<li>优化。分析和优化方法的二进制代码；根据proguard-android-optimize.txt中的描述，优化可能会造成一些潜在风险，不能保证在所有版本的Dalvik上都正常运行。</li>
<li>混淆。把类名、属性名、方法名替换为简短且无意义的名称；</li>
<li>预校验。添加预校验信息。这个预校验是作用在Java平台上的，Android平台上不需要这项功能，去掉之后还可以加快混淆速度。</li>
</ol>
<p>这四个流程默认开启。</p>
<p>在 Android 项目中我们可以选择将“优化”和“预校验”关闭，对应命令是<code>-dontoptimize</code>、<code>-dontpreverify</code>（当然，默认的 <code>proguard-android.txt</code> 文件已包含这两条混淆命令，不需要开发者额外配置）。</p>
<h3 id="2-资源压缩">2. 资源压缩</h3>
<p>资源压缩将移除项目及依赖的库中未被使用的资源，这在减少 apk 包体积上会有不错的效果，一般建议开启。具体做法是在 <code>build.grade</code> 文件中，将 <code>shrinkResources</code> 属性设置为 <code>true</code>。需要注意的是，<strong>只有在用minifyEnabled true开启了代码压缩后，资源压缩才会生效</strong>。</p>
<p>资源压缩包含了“合并资源”和“移除资源”两个流程。</p>
<p>“合并资源”流程中，名称相同的资源被视为重复资源会被合并。需要注意的是，这一流程不受shrinkResources属性控制，也无法被禁止， gradle 必然会做这项工作，因为假如不同项目中存在相同名称的资源将导致错误。gradle 在四处地方寻找重复资源：<br>
- src/main/res/ 路径</p>
<ul>
<li>不同的构建类型（debug、release等等）</li>
<li>不同的构建渠道</li>
<li>项目依赖的第三方库</li>
</ul>
<p>合并资源时按照如下优先级顺序：</p>
<pre><code>依赖 -&gt; main -&gt; 渠道 -&gt; 构建类型
</code></pre>
<p>举个例子，假如重复资源同时存在于<code>main</code>文件夹和不同渠道中，gradle 会选择保留渠道中的资源。</p>
<p>同时，如果重复资源在同一层次出现，比如<code>src/main/res/</code> 和 <code>src/main/res2/</code>，则 gradle 无法完成资源合并，这时会报资源合并错误。</p>
<p>“移除资源”流程则见名知意，需要注意的是，类似代码，混淆资源移除也可以定义哪些资源需要被保留，这点在下文给出。</p>
<h2 id="三-自定义混淆规则">三、自定义混淆规则</h2>
<p>在上文“混淆配置”中有这样一行代码</p>
<pre><code>proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
</code></pre>
<p>这行代码定义了混淆规则由两部分构成：位于 SDK 的 <code>tools/proguard/</code> 文件夹中的 <code>proguard-android.txt</code> 的内容以及默认放置于模块根目录的 <code>proguard-rules.pro</code> 的内容。前者是 SDK 提供的默认混淆文件（内容见附录1），后者是开发者自定义混淆规则的地方。</p>
<h3 id="1-常见混淆命令">1. 常见混淆命令：</h3>
<ul>
<li>optimizationpasses</li>
<li>dontoptimize</li>
<li>dontusemixedcaseclassnames</li>
<li>dontskipnonpubliclibraryclasses</li>
<li>dontpreverify</li>
<li>dontwarn</li>
<li>verbose</li>
<li>optimizations</li>
<li>keep</li>
<li>keepnames</li>
<li>keepclassmembers</li>
<li>keepclassmembernames</li>
<li>keepclasseswithmembers</li>
<li>keepclasseswithmembernames</li>
</ul>
<p>在第一部分 Android 混淆最佳实践中已介绍部分需要使用到的混淆命令，这里不再赘述，详情请查阅 <a href="http://proguard.sourceforge.net/">官网</a>。需要特别介绍的是与保持相关元素不参与混淆的规则相关的几种命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-keep</td>
<td style="text-align:left">防止类和成员被移除或者被重命名</td>
</tr>
<tr>
<td style="text-align:left">-keepnames</td>
<td style="text-align:left">防止类和成员被重命名</td>
</tr>
<tr>
<td style="text-align:left">-keepclassmembers</td>
<td style="text-align:left">防止成员被移除或者被重命名</td>
</tr>
<tr>
<td style="text-align:left">-keepnames</td>
<td style="text-align:left">防止成员被重命名</td>
</tr>
<tr>
<td style="text-align:left">-keepclasseswithmembers</td>
<td style="text-align:left">防止<strong>拥有该成员的</strong>类和成员被移除或者被重命名</td>
</tr>
<tr>
<td style="text-align:left">-keepclasseswithmembernames</td>
<td style="text-align:left">防止<strong>拥有该成员的</strong>类和成员被重命名</td>
</tr>
</tbody>
</table>
<h3 id="2-保持元素不参与混淆的规则">2. 保持元素不参与混淆的规则</h3>
<p>形如：</p>
<pre><code>[保持命令] [类] {
    [成员] 
}
</code></pre>
<p>“类”代表类相关的限定条件，它将最终定位到某些符合该限定条件的类。它的内容可以使用：</p>
<ul>
<li>具体的类</li>
<li>访问修饰符（public、protected、private）</li>
<li>通配符*，匹配任意长度字符，但不含包名分隔符(.)</li>
<li>通配符**，匹配任意长度字符，并且包含包名分隔符(.)<br>
- extends，即可以指定类的基类<br>
- implement，匹配实现了某接口的类</li>
<li>$，内部类</li>
</ul>
<p>“成员”代表类成员相关的限定条件，它将最终定位到某些符合该限定条件的类成员。它的内容可以使用：</p>
<ul>
<li><code>&lt;init&gt;</code> 匹配所有构造器</li>
<li><code>&lt;fields&gt;</code> 匹配所有域</li>
<li><code>&lt;methods&gt;</code> 匹配所有方法</li>
<li>通配符*，匹配任意长度字符，但不含包名分隔符(.)</li>
<li>通配符**，匹配任意长度字符，并且包含包名分隔符(.)</li>
<li>通配符***，匹配任意参数类型<br>
- …，匹配任意长度的任意类型参数。比如 <code>void test(…)</code> 就能匹配任意 <code>void test(String a)</code> 或者是 <code>void test(int a, String b)</code> 这些方法。</li>
<li>访问修饰符（public、protected、private）</li>
</ul>
<p>举个例子，假如需要将 <code>name.huihui.test</code>包下所有继承 <code>Activity</code> 的 <code>public</code> 类及其构造函数都保持住，可以这样写：</p>
<pre><code>-keep public class name.huihui.test.** extends Android.app.Activity {
    &lt;init&gt;
}
</code></pre>
<h3 id="3-常用的自定义混淆规则">3. 常用的自定义混淆规则</h3>
<ul>
<li>不混淆某个类</li>
</ul>
<pre><code>-keep public class name.huihui.example.Test { *; }
</code></pre>
<ul>
<li>不混淆某个包所有的类</li>
</ul>
<pre><code>-keep class name.huihui.test.** { *; }
</code></pre>
<ul>
<li>不混淆某个类的子类</li>
</ul>
<pre><code>-keep public class * extends name.huihui.example.Test { *; }
</code></pre>
<ul>
<li>不混淆所有类名中包含了“model”的类及其成员</li>
</ul>
<pre><code>-keep public class **.*model*.** {*;}
</code></pre>
<ul>
<li>不混淆某个接口的实现</li>
</ul>
<pre><code>-keep class * implements name.huihui.example.TestInterface { *; }
</code></pre>
<ul>
<li>不混淆某个类的构造方法</li>
</ul>
<pre><code>-keepclassmembers class name.huihui.example.Test { 
    public &lt;init&gt;(); 
}
</code></pre>
<ul>
<li>不混淆某个类的特定的方法</li>
</ul>
<pre><code>-keepclassmembers class name.huihui.example.Test { 
    public void test(java.lang.String); 
}
</code></pre>
<h2 id="四-自定义资源保持规则">四、自定义资源保持规则</h2>
<h3 id="1-keepxml">1. keep.xml</h3>
<p>用<code>shrinkResources true</code>开启资源压缩后，所有未被使用的资源默认被移除。假如你需要定义哪些资源必须被保留，在 <code>res/raw/</code>路径下创建一个 xml 文件，例如 <code>keep.xml</code>。</p>
<p>通过一些属性的设置可以实现定义资源保持的需求，可配置的属性有：<br>
- <code>tools:keep</code> 定义哪些资源需要被保留（资源之间用“,”隔开）<br>
- <code>tools:discard</code> 定义哪些资源需要被移除（资源之间用“,”隔开）<br>
- <code>tools:shrinkMode</code> 开启严格模式</p>
<p>当代码中通过 <code>Resources.getIdentifier()</code> 用动态的字符串来获取并使用资源时，普通的资源引用检查就可能会有问题。例如，如下代码会导致所有以“img_”开头的资源都被标记为已使用。</p>
<pre><code>String name = String.format(&quot;img_%1d&quot;, angle + 1);
res = getResources().getIdentifier(name, &quot;drawable&quot;, getPackageName());
</code></pre>
<p>我们可以设置 <code>tools:shrinkMode</code> 为 <code>strict</code> 来开启严格模式，使只有确实被使用的资源被保留。</p>
<p>以上就是自定义资源保持规则相关的配置，举个例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    tools:keep=&quot;@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*&quot;
    tools:discard=&quot;@layout/unused2&quot;
    tools:shrinkMode=&quot;strict&quot;/&gt;
</code></pre>
<h3 id="2-移除替代资源">2. 移除替代资源</h3>
<p>一些替代资源，例如多语言支持的 <code>strings.xml</code>，多分辨率支持的 <code>layout.xml</code> 等，在我们不需要使用又不想删除掉时，可以使用资源压缩将它们移除。</p>
<p>我们使用 <code>resConfig</code> 属性来指定需要支持的属性，例如</p>
<pre><code>android {
    defaultConfig {
        ...
        resConfigs &quot;en&quot;, &quot;fr&quot;
    }
}
</code></pre>
<p>其他未显式声明的语言资源将被移除。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://developer.android.com/studio/build/shrink-code.html">Shrink Your Code and Resources</a></li>
<li><a href="http://proguard.sourceforge.net/">proguard</a></li>
<li><a href="http://blog.csdn.net/sinyu890807/article/details/50451259">Android安全攻防战，反编译与混淆技术完全解析（下）</a></li>
<li><a href="http://www.jianshu.com/p/7436a1a32891">Android混淆从入门到精通</a></li>
<li><a href="http://rensanning.iteye.com/blog/2224635">Android代码混淆之ProGuard</a></li>
</ul>
<h2 id="附录">附录</h2>
<ol>
<li><code>proguard-android.txt</code>文件内容</li>
</ol>
<pre><code>#包名不混合大小写
-dontusemixedcaseclassnames

#不跳过非公共的库的类
-dontskipnonpubliclibraryclasses

#混淆时记录日志
-verbose

#关闭预校验
-dontpreverify

#不优化输入的类文件
-dontoptimize

#保护注解
-keepattributes *Annotation*

#保持所有拥有本地方法的类名及本地方法名
-keepclasseswithmembernames class * {
    native &lt;methods&gt;;
}

#保持自定义View的get和set相关方法
-keepclassmembers public class * extends android.view.View {
   void set*(***);
   *** get*();
}

#保持Activity中View及其子类入参的方法
-keepclassmembers class * extends android.app.Activity {
   public void *(android.view.View);
}

#枚举
-keepclassmembers enum * {
    **[] $VALUES;
    public *;
}

#Parcelable
-keepclassmembers class * implements android.os.Parcelable {
  public static final android.os.Parcelable$Creator CREATOR;
}

#R文件的静态成员
-keepclassmembers class **.R$* {
    public static &lt;fields&gt;;
}

-dontwarn android.support.**

#keep相关注解
-keep class android.support.annotation.Keep

-keep @android.support.annotation.Keep class * {*;}

-keepclasseswithmembers class * {
    @android.support.annotation.Keep &lt;methods&gt;;
}

-keepclasseswithmembers class * {
    @android.support.annotation.Keep &lt;fields&gt;;
}

-keepclasseswithmembers class * {
    @android.support.annotation.Keep &lt;init&gt;(...);
}
</code></pre>
<h2 id="写在最后">写在最后</h2>
<p>十分感谢你能看到最后，因本人水平有限，如有错漏还请不吝赐教，在此先行谢过。</p>
<p>同时，假如有这方面的困惑或者讨论，也十分欢迎联系我。</p>
<p>正文引用到此结束，文章有一张图片，实在是没找到，所以一直是空着的。</p>
<h2 id="我有话说">我有话说</h2>
<p>学了一波，发现其实 ProGuard 根本不难，而且，实际项目中，也不会引起线上错误日志调试困难，因为 ProGuard 完成后都会生成 mapping 文件，mapping 文件记录着所有符号表前后映射关系，借助这个文件，许多错误日志收集平台都能在线上反向解析出错误相关的源代码，现在几乎所有平台都会支持上传 mapping 文件。所以我现在都后悔学晚了。下次得抓紧。</p>
<p>本文封面图：Photo by <a href="https://unsplash.com/@ph_an_tom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Duangphorn Wiriya</a> on <a href="https://unsplash.com/search/photos/confuse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用 MotionLayout 来做过渡动画]]></title>
        <id>https://cherrylover.github.io/post/yong-motionlayout-lai-zuo-guo-du-dong-hua</id>
        <link href="https://cherrylover.github.io/post/yong-motionlayout-lai-zuo-guo-du-dong-hua">
        </link>
        <updated>2019-07-13T09:40:14.000Z</updated>
        <content type="html"><![CDATA[<p>MotionLayout 是一个 Google 官方出品用于制作 Android 中的过渡动画的框架。用来它就能轻松的做出一些较为复杂的动画效果。</p>
<blockquote>
<p>由于 MotionLayout 是基于 ConstraintLayout ，所以其中涉及到了部分关于 ConstraintLayout 的基本知识，本文按下不表，对 ConstraintLayout 不熟悉的同学，可以查看鸿洋的<a href="https://blog.csdn.net/lmj623565791/article/details/78011599">这篇博客</a>。</p>
</blockquote>
<p>MotionLayout 是 ConstraintLayout 的子类，并且在 ConstraintLayout 发展到 2.0 时才加入 ConstraintLayout 这个库，本文所使用的依赖为：</p>
<pre><code class="language-groovy">implementation 'androidx.constraintlayout:constraintlayout:2.0.0-beta2'
</code></pre>
<p>接下来让我们进入正题，先来看看我用 MotionLayout 制作的一个 Demo。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/blog_motion_login.gif" alt=""></p>
<p>在这个例子中，当点击 Login 按钮时，Login 按钮的长度进行不断缩小，缩小到一定尺寸时，外层的 ProgressBar 还是逐渐由不可见变为可见，同时，Login 按钮上的字进行了淡入淡出的动画效果。</p>
<p>MotionLayout 能做的不仅如此，它还能做到其他更为好玩有趣的过渡动画。现在让我们来学一下吧。</p>
<p>过渡动画，顾名思义就是在状态之间进行过渡的动画效果，防止页面内 View 出现瞬间移动的效果。而 MotionLayout 的重点其实就是状态。开发者只需要定义好对应状态下 View 的相对位置，以及相关属性，其后 MotionLayout 便会自动为其增加动的效果。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/blog_motion_login_1.gif" alt=""></p>
<p>这样的一个最简单的效果是怎么做出来的呢？</p>
<p>首先我们需要在资源文件夹 <code>res</code> 下新建一个名为 xml 的资源文件夹，然后再 xml 文件夹内新建一个根节点是 <code>MotionScene</code> 的 xml 文件，demo 中这个 xml 的文件名为 login_animator。</p>
<p>以下就是实现 Login 按钮长度变换的过渡动画。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;MotionScene xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;

    &lt;Transition
        app:constraintSetEnd=&quot;@id/a_login_end&quot;
        app:constraintSetStart=&quot;@id/a_login_start&quot;
        app:duration=&quot;1000&quot;&gt;
        &lt;OnClick
            app:clickAction=&quot;toggle&quot;
            app:targetId=&quot;@id/tv_action_login&quot; /&gt;

    &lt;/Transition&gt;

    &lt;ConstraintSet android:id=&quot;@+id/a_login_start&quot;&gt;
        &lt;Constraint android:id=&quot;@+id/tv_action_login&quot;&gt;
            &lt;Layout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;48dp&quot;
								android:layout_marginTop=&quot;30dp&quot;
                android:layout_marginStart=&quot;30dp&quot;
                android:layout_marginEnd=&quot;30dp&quot;
                app:layout_constraintTop_toBottomOf=&quot;@id/et_passwd&quot; /&gt;
        &lt;/Constraint&gt;

    &lt;/ConstraintSet&gt;

    &lt;ConstraintSet android:id=&quot;@+id/a_login_end&quot;&gt;
        &lt;Constraint android:id=&quot;@+id/tv_action_login&quot;&gt;
            &lt;Layout
                android:layout_width=&quot;48dp&quot;
                android:layout_height=&quot;48dp&quot;
                android:layout_marginTop=&quot;30dp&quot;
                app:layout_constraintEnd_toEndOf=&quot;@+id/et_account&quot;
                app:layout_constraintStart_toStartOf=&quot;@+id/et_account&quot;
                app:layout_constraintTop_toBottomOf=&quot;@id/et_passwd&quot; /&gt;
        &lt;/Constraint&gt;

    &lt;/ConstraintSet&gt;

&lt;/MotionScene&gt;
</code></pre>
<p>仔细看其中的信息，其中大部分是我们都熟悉的，无非就是对 View 的相对位置的约定或是 View 自身属性的规定，少部分是关于过渡动画的。</p>
<p>我们先来看看这个文件的整体结构，首先根节点是 MotionScene ，MotionScene 节点下有一个 Transition 与两个 ConstraintSet 节点，而且 Transition 中有两个属性，一个是 constraintSetStart 另一个是 constraintSetEnd，这两个属性的值正好是两个 ConstraintSet 节点的 id，而 Transition 内子节点 OnClick 节点内的属性 targetId 则表明了当前 Transition 所指定的动画是作用于具体的 View 上。</p>
<p>如你所想，通过在 Transition 内指定某个 View 的两个状态下的不同属性，就能产生在这两个状态内的过渡动画，并且在 Translation 内通过组合不同的动画事件进行显示。比如点击产生的动画（OnClick），滑动产生的动画（OnSwipe），以及可改变某一帧动画效果的关键帧动画（KeyFrameSet）。</p>
<p>当我们把初始及结束状态下的属性及动画定义完成后，还需要回到我们的布局文件，将需要实现过渡动画的 View 的父布局改为 MotionLayout 并且给它添加一个值为刚才我们新建那个 xml 文件的引用的属性 layoutDescription。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.motion.widget.MotionLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:layoutDescription=&quot;@xml/login_animator&quot;&gt;
    ......
&lt;/androidx.constraintlayout.motion.widget.MotionLayout&gt;
</code></pre>
<p>这就是一个最为简单的使用 MotionLayout 实现过渡动画的例子，它与开头我自己写的那个 demo 没什么差别，无非就是 demo 中变换的 View 的个数及属性多少不同而已。</p>
<p>在这个例子中，我们通过在 Transition 中定义了一个 OnClick 的子节点，而达到点击产生动画的效果。其中，targetId 即为产生动画效果的目标 View 的 id；clickAction 则是指明在是在开始或是再结束状态时产生动画，toggle 表示在开始和结束状态时均有效，它还有 transitionToStart 和 transitionToEnd 表示只在开始或是结束状态下有效。有兴趣的可以去试试。</p>
<p>除了 OnClick，我们还可以在 Translation 中定义 OnSwipe 节点，OnSwipe 就是用来处理屏幕上的滑动事件，以此配合指定的 View 实现过渡动画的效果。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/blog_motion_swipe_short.gif" alt=""></p>
<blockquote>
<p>给 MotionLayout 添加 motionDebug=&quot;SHOW_PATH&quot; 这个属性，即可查看 View 的过渡动画的轨迹。</p>
</blockquote>
<p>通过指定 View 的开始状态（靠近屏幕左边）和结束状态（靠近屏幕右边），然后在 Translation 中声明出滑动事件，即可。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;MotionScene xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;

    &lt;Transition
        app:constraintSetEnd=&quot;@id/v_swipe_end&quot;
        app:constraintSetStart=&quot;@id/v_swipe_start&quot;
        app:duration=&quot;1000&quot;&gt;
        &lt;OnSwipe
            app:dragDirection=&quot;dragRight&quot;
            app:touchRegionId=&quot;@id/v_swipe&quot; /&gt;

    &lt;/Transition&gt;
    
    &lt;ConstraintSet android:id=&quot;@+id/v_swipe_start&quot;&gt;
        &lt;Constraint android:id=&quot;@+id/v_swipe&quot;&gt;
            &lt;Layout
                android:layout_width=&quot;48dp&quot;
                android:layout_height=&quot;48dp&quot;
                app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
                app:layout_constraintStart_toStartOf=&quot;parent&quot;
                app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
        &lt;/Constraint&gt;

    &lt;/ConstraintSet&gt;

    &lt;ConstraintSet android:id=&quot;@+id/v_swipe_end&quot;&gt;
        &lt;Constraint android:id=&quot;@+id/v_swipe&quot;&gt;
            &lt;Layout
                android:layout_width=&quot;48dp&quot;
                android:layout_height=&quot;48dp&quot;
                app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
                app:layout_constraintEnd_toEndOf=&quot;parent&quot;
                app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
        &lt;/Constraint&gt;

    &lt;/ConstraintSet&gt;

&lt;/MotionScene&gt;
</code></pre>
<p>在 OnSwipe 中，有两个属性，一个是 dragDirection 代表的是滑动的方向，touchRegionId 则指明了监听的滑动区域为 View 的滑动区域。既然能作用于 View 的滑动区域，是不是也能作用于整个屏幕的滑动区域呢？没错，touchAnchorId 则表示全部的滑动区域。OnSwipe 还有一些其他属性，比如：touchAnchorSide 表示监听 View 的哪个区域的滑动监听，如果不设置的话，是 View 外的所有区域；onTouchUp 表示当在滑动过程中手指抬起时动画的动作（回到开始状态、回到结束状态、自动完成、停止等等）。</p>
<p>说实话，我在开始尝试 MotionLayout 的时候被 OnSwipe 给吓到了，但是当我更进一步的使用 KeyFrameSet 的时候直喊 666。原因就是因为 KeyFrameSet 能做出更炫酷的效果。</p>
<p>KeyFrameSet 是作用于在过渡动画过程中的关键帧，通过指定动画关键进程时的状态来实现不同的效果。举个例子，当前的 View 滑动是一条直线，我想让在滑动过程中有一个先向上滑动，然后向下滑动以这种效果达到屏幕的最右侧。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/blog_motion_swipe_frame.gif" alt=""></p>
<p>View 的开始与结束状态没有发生改变，只是在过渡动画的中点区域进行改变 View 的坐标。</p>
<pre><code class="language-xml">&lt;Transition
    app:constraintSetEnd=&quot;@id/v_swipe_end&quot;
    app:constraintSetStart=&quot;@id/v_swipe_start&quot;
    app:duration=&quot;1000&quot;&gt;
    &lt;OnSwipe
        app:dragDirection=&quot;dragRight&quot;
        app:touchAnchorId=&quot;@id/v_swipe&quot;
        app:touchAnchorSide=&quot;bottom&quot; /&gt;

    &lt;KeyFrameSet&gt;
        &lt;KeyPosition
            app:framePosition=&quot;50&quot;
            app:keyPositionType=&quot;parentRelative&quot;
            app:motionTarget=&quot;@+id/v_swipe&quot;
            app:percentY=&quot;0.3&quot; /&gt;
    &lt;/KeyFrameSet&gt;

&lt;/Transition&gt;
</code></pre>
<p>framePosition 表示在运动到整个运动过程的 50% 处，这个值的取值范围是 0 - 100，motionTarget 表示作用的 View，而 keyPositionType 与percentY 则共同决定了运动轨迹中弧度的变化方向。keyPositionType 控制 percentY 的坐标系的工作方式，它一共有 3 个值。parentRelative、deltaRelative、pathRelative。percentY 取值范围为 0 - 1，同时允许负数及大于 1 的值。</p>
<p>parentRelative 表示，坐标按照父布局的坐标进行处理，X，Y 轴的最大值均为1，X 轴向右为正，向左为负，Y 轴向下为正，向上为负。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/parentRelative'.png" alt=""></p>
<p>deltaRelative 表示开始状态的中心点为坐标系原点，X，Y 轴的最大值均为1，X 轴向右为正，向左为负，Y 轴向下为负，向上为正。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/deltaRelative.png" alt=""></p>
<p>pathRelative 表示开始状态的中心点为坐标系原点，X 轴为两个状中心点的构成的直线。X，Y 轴的最大值均为1，X 轴向结束状态方向为正，向开始状态方向为负，Y 轴向下为负，向上为正。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/pathRelative.png" alt=""></p>
<blockquote>
<p>keyPositionType 三个属性的描述图均来自 <a href="https://codelabs.developers.google.com/codelabs/motion-layout/index.html?index=..%2F..index#4">CodeLab</a></p>
</blockquote>
<p>KeyPostition 还有些其他有趣的属性，比如，控制运动轨迹是平滑的曲线还是直线的 curveFit，以及 transitionEasing 控制运动过程的加速或是减速等等。这里就不一一举例了。</p>
<p>而且，还可以同时存在多个关键帧进行控制动画效果。</p>
<pre><code class="language-xml">&lt;KeyFrameSet&gt;
    &lt;KeyPosition
        app:framePosition=&quot;50&quot;
        app:keyPositionType=&quot;parentRelative&quot;
        app:motionTarget=&quot;@+id/v_swipe&quot;
        app:percentY=&quot;0.3&quot; /&gt;
    &lt;KeyAttribute
        android:alpha=&quot;0&quot;
        app:framePosition=&quot;50&quot;
        app:motionTarget=&quot;@+id/v_swipe&quot; /&gt;
&lt;/KeyFrameSet&gt;
</code></pre>
<p>keyAttribute 是用于在过渡动画中控制 View 的属性，比如在动画执行 50% 时，View 的 alpha 值为 0 ，那么在从 0 - 50% 及 50% - 100% 的过程中，则由 MotionLayout 根据其执行时间自动改变 View 的状态。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/blog_motion_swipe_attr.gif" alt=""></p>
<p>刚才聊的都是关于动画本身的内容，实际上，MotionLayout 提供更多方式来对 View 进行状态改变，不只是通过在 ConstraintSet 中指定 Layout 来改变 View 的相对位置，它还提供了更为丰富的方法进行改变 View 的状态，比如：</p>
<blockquote>
<p>Motion 用于改变动画效果，例如加速、减速、先水平方法还是先垂直方向进行移动</p>
<p>CustomAttribute 用于改变自定义属性；</p>
<p>PropertySet 用于改变 View 特定的几个属性；</p>
<p>Transform 用于改变 View 中涉及到属性动画的属性，例如：rotation、scaleX 等。用法也很简单，像 Layout 那样声明出来即可。</p>
</blockquote>
<pre><code class="language-xml">&lt;ConstraintSet android:id=&quot;@+id/v_swipe_start&quot;&gt;
    &lt;Constraint android:id=&quot;@+id/v_swipe&quot;&gt;
        &lt;CustomAttribute
            app:attributeName=&quot;backgroundColor&quot;
            app:customColorValue=&quot;@color/colorAccent&quot; /&gt;
        &lt;Transform
            android:scaleX=&quot;1.0&quot;
            android:scaleY=&quot;1.0&quot; /&gt;
        &lt;Layout
            android:layout_width=&quot;48dp&quot;
            android:layout_height=&quot;48dp&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintStart_toStartOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    &lt;/Constraint&gt;

&lt;/ConstraintSet&gt;

&lt;ConstraintSet android:id=&quot;@+id/v_swipe_end&quot;&gt;
    &lt;Constraint android:id=&quot;@+id/v_swipe&quot;&gt;
        &lt;CustomAttribute
            app:attributeName=&quot;backgroundColor&quot;
            app:customColorValue=&quot;@color/colorPrimary&quot; /&gt;
        &lt;Transform
            android:scaleX=&quot;3.0&quot;
            android:scaleY=&quot;3.0&quot; /&gt;
        &lt;Layout
            android:layout_width=&quot;48dp&quot;
            android:layout_height=&quot;48dp&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    &lt;/Constraint&gt;

&lt;/ConstraintSet&gt;
</code></pre>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/blog/motionLayout/blog_motion_swipe_attr_more.gif" alt=""></p>
<blockquote>
<p>由于放大倍数较大，超出屏幕，所以在结束状态时显示存在异常。</p>
</blockquote>
<p>怎么样，MotionLayout 是不是比想象中的好玩一些，就是现在不太方便调试，每次调试都需要运行，不过呢，现在这个还没发布正式版，估计在正式版中 Google 应该会解决这个问题。</p>
<p>本文首发于<a href="https://jiangjiwei.site/">个人博客</a>，文中全部源代码已上传至 <a href="https://github.com/CherryLover/BlogTest">GitHub</a>，代码分支为：motionLayout。喜欢的麻烦点个🌟。</p>
<p>推荐学习网站：<a href="https://codelabs.developers.google.com/codelabs/motion-layout/index.html?index=..%2F..index#0">CodeLab</a>。</p>
<p>本文封面图：Photo by <a href="https://unsplash.com/@nasa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">NASA</a> on <a href="https://unsplash.com/search/photos/nasa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[来学一波 Navigation]]></title>
        <id>https://cherrylover.github.io/post/lai-xue-yi-bo-navigation</id>
        <link href="https://cherrylover.github.io/post/lai-xue-yi-bo-navigation">
        </link>
        <updated>2019-06-29T07:57:02.000Z</updated>
        <summary type="html"><![CDATA[<p>Navigation 是一个谷歌官方推出的一个用于 APP 内部便捷切换内容（Fragment 或 Activity）的库。从而使得 APP 内的页面跳转更简单。</p>
<p>我知道它的时候它的版本已经是 2.0.0 了，也是时候来学习一波了。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Navigation 是一个谷歌官方推出的一个用于 APP 内部便捷切换内容（Fragment 或 Activity）的库。从而使得 APP 内的页面跳转更简单。</p>
<p>我知道它的时候它的版本已经是 2.0.0 了，也是时候来学习一波了。</p>
<!-- more --> 
<p>无论什么时候，学习的第一手资料不能缺了官方出品的 <a href="https://codelabs.developers.google.com/codelabs/android-navigation/#0">CodeLab</a>。相信你，看了 CodeLab 之后就能对 Navigation 有一个简单的了解。本人也是对 CodeLab 学习之后才写下了这篇博客，主要内容都能在 CodeLab 上找到。不过 CodeLab 里面是英文的讲解，而且其中的代码是使用 Kotlin 编写的，这篇博客是以 Java 代码的方式进行的。</p>
<p>还一件事情，Navigation 的原生支持是从 Android Studio 3.3 开始的，3.2 版本的需要在设置面板的 Experimental 模块中启用 Navigation 编辑器。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628144412075.png" alt="image-20190628144412075"></p>
<blockquote>
<p>图片来自 CodeLab。</p>
</blockquote>
<p>下面开始正题</p>
<h2 id="navigation-graph-和-navhostfragment">Navigation Graph 和 NavHostFragment</h2>
<p>首先，添加依赖。</p>
<pre><code>implementation 'androidx.navigation:navigation-fragment:2.0.0'
implementation 'androidx.navigation:navigation-ui:2.0.0'
</code></pre>
<p>之后，在 res 文件夹下创建类型为 navigation 的资源文件夹，Android Studio 会自动在这个文件夹下生产一个名为 navigation.xml 的文件，这个文件的作用就是用于描述 Fragment 及相应的跳转逻辑、动画、参数等信息。这个文件也叫做 <strong>Navigation Graph</strong>。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628144907092.png" alt="create_navigation_folder"></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
            android:id=&quot;@+id/navigation&quot;&gt;

&lt;/navigation&gt;
</code></pre>
<p>默认的 Navigation Graph 文件就只有一个根节点，如果我们有更多的 Fragment，添加进来，会有不同的子节点，子节点代表的就是 Fragment，fragment 节点中描述关于 Fragment 的相关信息，并且在 fragment 节点中还可以其他子节点，比如，action、argument、deepLink。他们分别用于表示 Fragment 的相关信息。往后会讲到的。现在我们现在创建一个 Fragment ，就叫 RootFragment 好了。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
             xmlns:tools=&quot;http://schemas.android.com/tools&quot;
             android:layout_width=&quot;match_parent&quot;
             android:layout_height=&quot;match_parent&quot;
             tools:context=&quot;.fragment.RootFragment&quot;&gt;
    &lt;TextView
            android:layout_gravity=&quot;center&quot;
            android:gravity=&quot;center&quot;
            android:layout_width=&quot;match_parent&quot;
            android:textSize=&quot;24sp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:text=&quot;Root Fragment&quot;/&gt;

&lt;/FrameLayout&gt;
</code></pre>
<p>只是在页面上显示出这个 Fragment 的名字，Java 代码中没有做任何事情。现在让我们回到 Navigation Graph 中，我们是初学者，不知道或者说不了解 Fragment 节点有哪些属性可以去使用，可以使用 Navigation Graph 的图形化界面，刚才我们看了 Navigation Graph 的代码，现在来看一下，图形化编辑页面。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628150519705.png" alt="graph_design"></p>
<blockquote>
<p>左边区域：是已经添加进来的 Fragment 以及承载这些 Fragment 的页面；</p>
<p>中间区域：Fragment 的跳转示意图；</p>
<p>右边区域：是当前选中的 Fragment 的属性展示区；</p>
</blockquote>
<p>页面中间已经提示我们了，点击那个图标，添加一个目标。试试看吧，从 Android Studio 展示出的列表中，找到我们刚才创建的 RootFragment。这时，页面已经发生了变化。我们刚才创建的 RootFragment 的样子已经出现了，而且名称前还有一个小图标，这表示 RootFragment 是 Navigation 管理页面的第一个页面也是开始页面。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628150937246.png" alt="image-20190628150937246"></p>
<p>页面右侧出现了一些属性，我们暂时可以不用管，现在我只想先运行起来，看看效果。不过在这之前，我们还需要改造一下，之前新建项目自动生成的 MainActivity。先打开 activity_main.xml 的图形化编辑页面，然后在 Palette 类型列表中找到 <strong>NavHostFragment</strong> 并拖拽到页面上，此时会弹出一个框，让你选择 Navigation Graph，我们选择刚才自动创建的文件即可。</p>
<blockquote>
<p>Android Studio 的布局文件的拖拽，不是太好用，需要手动切换到源代码形式，简单改动一下页面代码，我们让这个 NavHostFrgament 组件填充满整个容器即可。</p>
</blockquote>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628151745388.png" alt="image-20190628151745388"></p>
<p>最终的 activity_main.xml 的源文件如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;fragment
        android:id=&quot;@+id/fragment&quot;
        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:defaultNavHost=&quot;true&quot;
        app:navGraph=&quot;@navigation/navigation&quot; /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<p>然后运行项目即可。这就是一个最简单的使用 Navigation 的例子，而且其中根本就没什么难度。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628161622969.png" alt="image-20190628161622969"></p>
<p>好，现在我们来回过头来看看，刚刚我们都做什么。我们真正有效的内容是从把 RootFragment 添加到 Navigation Graph 中，我们去看一下，Navigation Graph 的源代码。说不定能从那里发现点什么东西。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/navigation&quot;
    app:startDestination=&quot;@id/rootFragment&quot;&gt;

    &lt;fragment
        android:id=&quot;@+id/rootFragment&quot;
        android:name=&quot;me.monster.blogtest.fragment.RootFragment&quot;
        android:label=&quot;fragment_root&quot;
        tools:layout=&quot;@layout/fragment_root&quot; /&gt;
&lt;/navigation&gt;
</code></pre>
<p>这个文件跟之前自动生成的没什么区别，无非就是多了一个 fragment 节点，以及根节点上多了一个 startDestination 属性。难道就是因为这个属性？是的，没错，在 Navigation 中我们使用 Destination(目标)来描述 Fragment 之间的跳转关系。这里的 startDestination 代表的就是这个是 Navigation 整个页面跳转管理栈的最根级页面。</p>
<p>再来看看那个添加到 MainActivity 页面的 NavHostFragment 组件。它其实就是一个布局文件中的 fragmen 组件，跟我们正常使用的没什么不同，非要说不同，那就是其中的 name、defaultNavHost 以及 navGraph 这三个属性了。</p>
<p>name 属性我们都知道，navGraph 属性里面的值是刚才创建 Navigation Graph，猜一下，就是把 Navigation Graph 引用到了这个 NavHostFragment 中。那最后一个 defaultNavHost 属性呢？那就是拦截系统返回按钮的点击事件的。</p>
<pre><code class="language-xml">&lt;fragment
    android:id=&quot;@+id/fragment&quot;
    android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:defaultNavHost=&quot;true&quot;
    app:navGraph=&quot;@navigation/navigation&quot; /&gt;
</code></pre>
<h2 id="navcontroller">NavController</h2>
<p>单单一个 Fragment 没啥意思，不好玩，这回我们再加一个页面(SettingsFragment)。尝试着从 RootFragment 页面点击按钮切换到 SettingsFragment 页面。然后在 SettingsFragment 页面点击按钮返回到 RootFragment 页面。</p>
<blockquote>
<p>说是 SettingsFragment，里面就一个 Button 一个 TextView，布局代码就不贴了。</p>
</blockquote>
<p>Fragment 准备好了，该往 Navigation Graph 里添加了，按照刚才添加 RootFragment 的方式再来一次，不过，这次比上次多一步。选中 RootFragment，点击 RootFragment 右边的小圆点然后牵引到右侧的 SettingsFragment。这样他们两个就建立一种关系。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628160038102.png" alt="image-20190628160038102"></p>
<p>来看一下源代码吧。我们发现，除了增加了一个 fragment 节点之外，原来的 RootFragment 的节点上还增加了一个子节点 action 。事实上，action 节点就是用来描述 Fragmen 之间的页面跳转的关系的，其中 destination 属性的值就是目标 fragment 的 id。</p>
<pre><code class="language-xml">&lt;fragment
    android:id=&quot;@+id/rootFragment&quot;
    android:name=&quot;me.monster.blogtest.fragment.RootFragment&quot;
    android:label=&quot;fragment_root&quot;
    tools:layout=&quot;@layout/fragment_root&quot; /&gt;

&lt;!--上面是原来的代码，下面是新代码--&gt;

&lt;fragment
    android:id=&quot;@+id/rootFragment&quot;
    android:name=&quot;me.monster.blogtest.fragment.RootFragment&quot;
    android:label=&quot;fragment_root&quot;
    tools:layout=&quot;@layout/fragment_root&quot; &gt;
    &lt;action
        android:id=&quot;@+id/action_rootFragment_to_settingsFragment2&quot;
        app:destination=&quot;@id/settingsFragment&quot; /&gt;
&lt;/fragment&gt;
&lt;fragment
    android:id=&quot;@+id/settingsFragment&quot;
    android:name=&quot;me.monster.blogtest.fragment.SettingsFragment&quot;
    android:label=&quot;SettingsFragment&quot; /&gt;
</code></pre>
<p>继续往下，我们为 RootFragment 页面绑定点击事件。</p>
<pre><code class="language-java">private void toSettings() {
    btnToSettings.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Navigation.findNavController(btnToSettings)
                    .navigate(R.id.action_rootFragment_to_settingsFragment);
        }
    });
}
</code></pre>
<p>这一看就知道了，通过 Navigation 找到一个叫 <strong>NavController</strong> 的东西，然后执行 navigate 方法，这个方法里面传的值就是刚才 RootFragment 子节点 action 的 id 的值。先运行一下看看效果。</p>
<blockquote>
<ol>
<li>亲测点击按钮能跳转到 SettingsFragment 页面。下面的 Gif 动图只是表示能从 RootFragment 到 SettingsFragment，闪回到 RootFragment 页面只是 Gif 的重新播放。</li>
<li>如果你在 SettingsFragment 点击系统的返回键，是能返回到 RootFragment。这就是 MainActivity 中 NavHostFragment 组件的属性 <code>app:defaultNavHost=&quot;true&quot;</code> 起到的作用，有兴趣的话，可以改成 false 然后再试一下效果。</li>
</ol>
</blockquote>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/Blognav_toSettings.gif" alt=""></p>
<p>现在，让我们再次为 SettingsFragment 添加按钮的点击事件吧。</p>
<pre><code class="language-java">private void goBack() {
    btnToRoot.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Navigation.findNavController(btnToRoot)
                    .popBackStack();
        }
    });
}
</code></pre>
<p>和之前跳转到这个页面的方式差不多，只是最后执行的方法变成了 <code>popBackStack</code> 。</p>
<p>嗯，挺好的，不过，我们有些时候需要在两个 Fragment 之间做切换动画，这个怎么办？这个也不难，在Navigation Graph 中跳转的 action 内增加属性即可。呐，这样就行了，而且还可以用过 Java 代码来实现。</p>
<pre><code class="language-xml">&lt;fragment
    android:id=&quot;@+id/rootFragment&quot;
    android:name=&quot;me.monster.blogtest.fragment.RootFragment&quot;
    android:label=&quot;fragment_root&quot;
    tools:layout=&quot;@layout/fragment_root&quot;&gt;
    &lt;action
        android:id=&quot;@+id/action_rootFragment_to_settingsFragment&quot;
        app:destination=&quot;@id/settingsFragment&quot;
        app:enterAnim=&quot;@anim/slide_in_right&quot;
        app:exitAnim=&quot;@anim/slide_out_left&quot;
        app:popEnterAnim=&quot;@anim/slide_in_left&quot;
        app:popExitAnim=&quot;@anim/slide_out_right&quot; /&gt;
&lt;/fragment&gt;
</code></pre>
<p>Java 代码</p>
<pre><code class="language-java">Navigation.findNavController(btnToSettings)
    .navigate(R.id.action_rootFragment_to_settingsFragment);
//                上面是原来的代码，下面是新代码

NavOptions options = new NavOptions.Builder()
    .setEnterAnim(R.anim.slide_in_right)
    .setExitAnim(R.anim.slide_out_left)
    .setPopEnterAnim(R.anim.slide_in_left)
    .setPopExitAnim(R.anim.slide_out_right)
    .build();

Navigation.findNavController(btnToSettings)
    .navigate(R.id.action_rootFragment_to_settingsFragment, null, options);
</code></pre>
<p>这里，我们调用了 navigate 这个方法，其中第二个参数是 Bundle 类型，我们填入了 null</p>
<p>，那如果正常填了值，Bundle 是不是就是传递到 SettingsFragment 了呢？答案是肯定的。不过 Navigation 还有另一种方式来传值—— <strong>Safe Args</strong>。</p>
<h3 id="safe-args">Safe Args</h3>
<blockquote>
<p>为啥要用 Safe Args 呢？</p>
<p>我也不知道为啥学，感觉如果单纯为了保证 key 安全的话，把 Bundle 里面的 key 抽取成常量值不也行吗？不太懂为啥要通过这种形式来做，不过呢，老话说得好，技多不压身。</p>
</blockquote>
<p>Safe Args 是配合 Navigation 使用的一个 Gradle 插件。首先你得先去配置：</p>
<p>首先在你项目的根目录的 build.gradle 文件中加上这些东西：</p>
<pre><code>repositories {
    google()
}
dependencies {
    classpath &quot;androidx.navigation:navigation-safe-args-gradle-plugin:2.0.0&quot;
}
</code></pre>
<p>然后还得在你的 app 或是 module 的目录下的 build.gradle 文件夹加入：</p>
<pre><code>apply plugin: &quot;androidx.navigation.safeargs&quot;
</code></pre>
<p>如果你想用 safe Args 生成的代码时 Kotlin 的话，还需要加入：</p>
<pre><code>aapply plugin: &quot;androidx.navigation.safeargs.kotlin&quot;
</code></pre>
<p>最最最重要的一点是，你要确认你的 build.properties 文件中有这么一行：</p>
<pre><code class="language-java">android.useAndroidX=true
</code></pre>
<p>当然了，如果你的项目本身就是用是 AndroidX 的依赖，就不用去确认了，肯定能通过的嘛。</p>
<p>现在我们就来从 RootFragmet 传递一个类型为 String 的备注名到 SettingsFragmen 吧。还是先通过图形化界面进行设置吧，选中 SettingsFragment，然后再右侧属性面板上找到 Argments 点击旁边的➕。</p>
<p>弹出一个框，我们填入一下信息，然后点击 add。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628191327486.png" alt="image-20190628191327486"></p>
<p>完成之后的 Navigation Graph 中 SettingsFragment 节点的内容变了。</p>
<pre><code class="language-xml">&lt;fragment
    android:id=&quot;@+id/settingsFragment&quot;
    android:name=&quot;me.monster.blogtest.fragment.SettingsFragment&quot;
    android:label=&quot;SettingsFragment&quot;/&gt;

&lt;!--上面是原来的代码，下面是新代码--&gt;

&lt;fragment
    android:id=&quot;@+id/settingsFragment&quot;
    android:name=&quot;me.monster.blogtest.fragment.SettingsFragment&quot;
    android:label=&quot;SettingsFragment&quot;&gt;
    &lt;argument
        android:name=&quot;nickName&quot;
        android:defaultValue=&quot;未设置&quot;
        app:argType=&quot;string&quot;
        app:nullable=&quot;true&quot; /&gt;
&lt;/fragment&gt;
</code></pre>
<blockquote>
<p>这个时候，Gradle 会自动生成 SettingFragmentArgs 以及 RootFragmentDirections 这两个类，在 generatedJava 这个文件夹下的包内。如果没有自动生成的话，clean 一下或是 rebuild 项目都行。</p>
</blockquote>
<p>现在就能直接通过 setNickName 的形式来设置待传递的值了。</p>
<pre><code class="language-java">String nickName = &quot;master&quot;;
RootFragmentDirections.ActionRootFragmentToSettingsFragment action =
        RootFragmentDirections.actionRootFragmentToSettingsFragment().setNickName(nickName);

Navigation.findNavController(btnToSettings)
        .navigate(action);
</code></pre>
<p>在 SettingsFragment 我们需要把值取出来，然后显示在屏幕上。</p>
<pre><code class="language-java">String nickName = SettingsFragmentArgs.fromBundle(getArguments()).getNickName();
tvNickName.setText(nickName);
</code></pre>
<p>怎么样，是不是很简单，这比之前我们用 Bundle 传值要方便的多啦，而且再也不用担心 Key 写错的问题了。真香。</p>
<p>好了，Navigation 的基本学习就到这了，感觉真的挺不错的。可以考虑用用了，不过现在好像主页面都是四个或是五个 Tab 页面，这用 Navigation 怎么实现呀？Google 早就替我们想好了。</p>
<h2 id="bottomnavigationview">BottomNavigationView</h2>
<p>来，我们新建一个 Activity，然后打开布局文件的图形化工具页面，用之前我们添加 NavHostFragment 组件的方式来添加一个 BottomNavigationView，然后让这个组件位于整个页面的底部。页面的其余部分全部都留给 NavHostFragment。因为我们又引入了一个新的 Fragment 管理栈，所以，需要再次新建一个 Navigation Graph 文件 tab_navigation。</p>
<p>下面就是 activity_tab.xml 以及 tab_navigation.xml 的代码。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.TabActivity&quot;&gt;

    &lt;com.google.android.material.bottomnavigation.BottomNavigationView
        android:id=&quot;@+id/nv_bottom_menu&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;48dp&quot;
        app:itemHorizontalTranslationEnabled=&quot;false&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt;

    &lt;fragment
        android:id=&quot;@+id/fragment3&quot;
        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        app:defaultNavHost=&quot;true&quot;
        app:layout_constraintBottom_toTopOf=&quot;@+id/nv_bottom_menu&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot;
        app:navGraph=&quot;@navigation/tab_navigation&quot; /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;

&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/tab_navigation&quot;&gt;

&lt;/navigation&gt;
</code></pre>
<p>接下来干什么呢？刚才我们创建是容器，用于容纳 Fragment 的，现在来创建三个 Fragment，这三个 Fragment 是用于填充进容器的内容。</p>
<p>分别是 FeedFragment、TimerFragment、MineFragment。这三个 Fragment 我们还是分别显示自己的名称。布局文件里也就一个 TextView，Java 代码中什么也不做，仅仅是用来显示。</p>
<p>有了三个 Fragment，我们现在去 tab_navigation 把这三个 Fragment 都添加进去。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:id=&quot;@+id/tab_navigation&quot;
    app:startDestination=&quot;@id/feedFragment&quot;&gt;

    &lt;fragment
        android:id=&quot;@+id/feedFragment&quot;
        android:name=&quot;me.monster.blogtest.tab.FeedFragment&quot;
        android:label=&quot;fragment_feed&quot;
        tools:layout=&quot;@layout/fragment_feed&quot; /&gt;
    &lt;fragment
        android:id=&quot;@+id/timerFragment&quot;
        android:name=&quot;me.monster.blogtest.tab.TimerFragment&quot;
        android:label=&quot;fragment_timer&quot;
        tools:layout=&quot;@layout/fragment_timer&quot; /&gt;
    &lt;fragment
        android:id=&quot;@+id/mineFragment&quot;
        android:name=&quot;me.monster.blogtest.tab.MineFragment&quot;
        android:label=&quot;fragment_mine&quot;
        tools:layout=&quot;@layout/fragment_mine&quot; /&gt;
&lt;/navigation&gt;
</code></pre>
<p>现在，我们容器有了，内容有了，只差一个媒介，把它们进行关联了。打开 activity_tab 的图形化界面，在左侧有一些属性，其中有一个属性是 menu。menu？就是那个经常用于页面右上角的 menu？它怎么会出现在这边？点击 menu 行最右边的按钮。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190628235937692.png" alt="image-20190628235937692"></p>
<p>弹出一个对话框，好像和一开始创建 NavHostFragment 是一样的，不同的是，当时有待选择的 Navigation Graph 文件，现在我们没有 menu 文件，那就创建一个吧。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190629000519557.png" alt="image-20190629000519557"></p>
<p>现在我们也有了 menu 文件。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;item
        android:id=&quot;@+id/feedFragment&quot;
        android:icon=&quot;@drawable/ic_tab_feed&quot;
        android:title=&quot;Feed&quot; /&gt;
    &lt;item
        android:id=&quot;@+id/timerFragment&quot;
        android:icon=&quot;@drawable/ic_tab_timer&quot;
        android:title=&quot;Timer&quot; /&gt;
    &lt;item
        android:id=&quot;@+id/mineFragment&quot;
        android:icon=&quot;@drawable/ic_tab_mine&quot;
        android:title=&quot;Mine&quot; /&gt;
&lt;/menu&gt;
</code></pre>
<p>现在再回去看 tab_activity.xml 发现 preview 已经变成了这样的。Cool</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190629110347302.png" alt="image-20190629110347302"></p>
<p>难道 Menu 就是那个把内容 (Fragment) 与容器 (NavHostFragment) 进行建立关系的媒介？是也不是，有那么一点关系，不过不太准确。还记得之前我们用与 RootFragment 和 SettingsFragment 进行切换页面的方式吗？一个是前进到下一个页面，一个是返回上一个页面，虽然最终的行为不同，但是它们都使用到了一个叫 <strong>NavController</strong> 的类，这个类实际上就是实现在 Fragment 之间进行跳转的类。</p>
<pre><code class="language-java">Navigation.findNavController(btnToSettings).navigate(action);
Navigation.findNavController(btnToRoot).popBackStack();
</code></pre>
<p>那我们是不是可以通过 Navigation Controller 并结合底部导航菜单的点击事件来对 Fragment 进行控制，从而实现 Fragment 之间的切换？是这样的，没错，不过 Google 帮助我们完成了很多复杂的事情，我们只需要在 TabActivity 中添加下面这些代码即可。</p>
<pre><code class="language-java">private void setUpNavBottom() {
    NavHostFragment hostFragment = (NavHostFragment) getSupportFragmentManager()
        .findFragmentById(R.id.fragment3);
    BottomNavigationView navMenu = findViewById(R.id.nv_bottom_menu);
    if (hostFragment != null) {
        NavController navController = hostFragment.getNavController();
        NavigationUI.setupWithNavController(navMenu, navController);
    }
}
</code></pre>
<p>第一行，findFragmentById 里填写的 id 就是我们在 tab_activity.xml 中 name 属性是 NavHostFragment 节点的 id。</p>
<p>然后再通过 <code>NavigationUI.setupWithNavController()</code> 将二者进行想管理，这样只要我们点击底部导航菜单就是自动实现 Fragment 的之间的切换，完全不需要开发者自己去写那么控制逻辑。事实上，<code>NavigationUI.setupWithNavController()</code> 这个方法有很多重载方法，不仅仅只是用在 BottomNavigationView，还有 NavigationView 等，在这里就不一一介绍了感兴趣的可以去试试。现在来看看效果。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/Blognav_bottomNav-1779718.gif" alt="Blognav_bottomNav"></p>
<h2 id="deeplink">DeepLink</h2>
<p>来来来，回顾一下刚才我们介绍的 Navigation Graph，它就是用于描述 Fragment 或者说用于描述内容信息的，刚才我们尝试了子节点 Fragment 的 action（页面跳转）与 arguments（Bundle 传值）节点，其实他还有一个子节点 deepLink。</p>
<p>不知道，你有没有遇到那种情况，朋友在微信上分享你一个连接，你一点开，页面上提示你使用微信的在浏览器打开，你在一点开发现，发现跳转到了一个应用的页面上去了。这种跳转方式在 Navigation 这个导航框架内叫做 deepLink。让我们来实现一下吧。</p>
<p>我们需要准备一个 Fragment，就叫 DeepLinkFragment 好了，这个页面我们跟之前的 Fragment 一样只显示 DeepLinkFragment 这个文字好了。layout 布局文件及 Java 代码就不贴了。现在再来看 Navigation Graph 中怎么写。</p>
<pre><code class="language-xml">fragment
    android:id=&quot;@+id/deepLinkFragment&quot;
    android:name=&quot;me.monster.blogtest.fragment.DeepLinkFragment&quot;
    android:label=&quot;fragment_deep&quot;
    tools:layout=&quot;@layout/fragment_deep&quot; &gt;
    &lt;deepLink
        android:id=&quot;@+id/deepLink&quot;
        app:uri=&quot;www.example.com/{myarg}&quot; /&gt;
&lt;/fragment&gt;
</code></pre>
<p>是的，你没有看错，在 Navigation Graph 中就多了这么点东西，然后记得一定要记得在 manifest 的承载 DeepLinkFragment 的 Activity 节点内引入你的 Navigation Graph。</p>
<blockquote>
<ol>
<li>那里填的 url 后面大括号包裹着的是传入 DeepLinkFragment 的值，<code>myarg</code> 是 key，通过 Bundle 进行传递；</li>
<li>我在写这篇博客的时候，有两个 Navigation Graph 文件，一个是用于 RootFragment 与 SettingsFragment 进行跳转的 navigation.xml，一个是用于底部导航菜单栏的 tab_navigation.xml，我把 DeepLinkFragment 放在了 navigation.xml 中，所以下面的值是 @navigation/navigation。</li>
</ol>
</blockquote>
<pre><code class="language-xml">&lt;nav-graph android:value=&quot;@navigation/navigation&quot; /&gt;
</code></pre>
<p>来试一下，看看效果吧。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/Blognav_deepLink.gif" alt="Blognav_deepLink"></p>
<p>好了，我们整个 Navigation 的学习到这里也告一段落了，结束之前让我们用一幅图来回顾一下 Navigation。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190629150736867.png" alt="image-20190629150736867"></p>
<p>本文首发于<a href="https://jiangjiwei.site/">个人博客</a>，文中全部源代码已上传至 <a href="https://github.com/CherryLover/BlogTest">GitHub</a>，喜欢的麻烦点个🌟。<br>
本文封面图：Photo by <a href="https://unsplash.com/@jbcreate_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Joseph Barrientos</a> on <a href="https://unsplash.com/search/photos/navigation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 泛型]]></title>
        <id>https://cherrylover.github.io/post/java-fan-xing</id>
        <link href="https://cherrylover.github.io/post/java-fan-xing">
        </link>
        <updated>2019-06-27T11:04:17.000Z</updated>
        <summary type="html"><![CDATA[<p>泛型，在日常工作中，使用最广泛的就是集合及 Map 中，一直以来也没认真想过泛型，现在准备来学一下泛型。</p>
]]></summary>
        <content type="html"><![CDATA[<p>泛型，在日常工作中，使用最广泛的就是集合及 Map 中，一直以来也没认真想过泛型，现在准备来学一下泛型。</p>
<!-- more --> 
<p>来，先从最简单的开始，一个元素全部为 String 的集合开始。</p>
<pre><code class="language-java">ArrayList&lt;String&gt; nameList = new ArrayList&lt;&gt;();
nameList.add(&quot;张三&quot;);
nameList.add(&quot;李四&quot;);
nameList.add(&quot;王五&quot;);
System.out.println(nameList.toString());
</code></pre>
<p>我们一行一行看代码，第一行，是创建了一个泛型类型为 String 的 ArrayList 对象，往下三行分别向 nameList 中添加三个元素，最后进行打印。</p>
<blockquote>
<ol>
<li><code>new ArrayList&lt;&gt;();</code> 这种写法是在 Java 1.7 及其之后才有的，在 Java 之前的版本，需要在 <code>&lt;&gt;</code> 内指定出具体的泛型类型，如：<code>new ArrayList&lt;String&gt;();</code> 简写是因为做了类型推断。</li>
<li>实际的 Android 开发中，最好还是别用 <code>System.out.println();</code>，这里只是个人学习 Demo 才这么写。</li>
</ol>
</blockquote>
<p>输出内容:</p>
<pre><code>[张三, 李四, 王五]
</code></pre>
<p>来，下面我们来自己创建一个泛型出来。为什么创建泛型呢？或者说我们创建什么泛型呢？实际上泛型可以作用于类、接口或是方法(函数)。</p>
<p>泛型类</p>
<pre><code class="language-java">   public class Rep&lt;T&gt; {
       private int code;
       private String message;
       private T result;
   }
</code></pre>
<p>这样的结构应该不会陌生，服务端在返回给客户端的数据就是按照这种形式进行组装的，其中 result 可以是任何类型的任何值，既有可能是 boolean 类型的 false，也有可能是 List 类型的集合。</p>
<blockquote>
<p>实际应该还有其他的内容，如 get 、set 方法等，此处略过。</p>
</blockquote>
<p>泛型接口</p>
<pre><code class="language-java">   public interface Shop&lt;T&gt; {
     T buy();
   
     int back(T product);
   }
</code></pre>
<p>定义了一个泛型的接口，内部包含两个没有方法体的方法。一个的返回值是泛型类型 T ，表示买了一个什么东西；一个的参数是泛型类型 T，表示一个什么东西退货退多少钱。这里的 <code>什么东西</code> 就是泛型类型 T。</p>
<p>泛型方法</p>
<pre><code class="language-java">   public T getResult() {
     return result;
   }
   
   public void setResult(T result) {
     this.result = result;
   }
</code></pre>
<p>这两个泛型方法就是简单的将泛型类中的 result 这个成员变量进行赋值和返回。</p>
<p>这好像没什么实际意义，来点有意思的东西。刚才我们定义了一个 Shop 的泛型接口，现在我们再来创建一个卖 Apple 的店(AppleShop，首先需要一个 Apple 的类，其次需要一个实现 Shop 接口的 AppleShop 类。</p>
<pre><code class="language-java">public class Apple {}

public class AppleShop implements Shop {
    @Override
    public Object buy() {
        return null;
    }

    @Override
    public int back(Object product) {
        return 0;
    }
}
</code></pre>
<p>唉，好像有点不对了，AppleShop 里面的 <code>buy()</code> 为什么返回的不是 Apple 对象还有那个 <code>back</code>方法为什么参数也成了 Object 而不是 Apple ？</p>
<p>原因在与：<code>class AppleShop implements Shop</code> 准确的来说是在于 <code>implements Shop</code> ，在实现泛型接口时，如果不指定具体的泛型类型（这里指的是 Apple）时，跟实现接口没什么区别，只是其中的泛型方法的返回值、参数全变成了 Object。</p>
<p>上面的 AppleShop 类相当于实现了下面这个接口。</p>
<pre><code class="language-java">public interface Shop {
    Object buy();

    int back(Object product);
}
</code></pre>
<p>那我想让他实现我想要的 Apple 类型的怎么做呢？在实现类的类名后 <code>&lt;类型名称&gt;</code> 即可。AppleShop 的正确写法如下：</p>
<pre><code class="language-java">public class AppleShop implements Shop&lt;Apple&gt; {
    @Override
    public Apple buy() {
        return new Apple();
    }

    @Override
    public int back(Apple product) {
        return 1;
    }
}
</code></pre>
<p>其中，buy 方法直接返回一个 Apple 对象，back 方法返回 1 元。</p>
<p>现在又有一家店既能买东西，又能修东西，它得先继承 Shop，我这回知道了，就这么写就行。</p>
<pre><code class="language-java">public interface Repairableable extends Shop&lt;T&gt;{
    
}
</code></pre>
<p>唉，不对，咋报错呢？</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/image-20190627171053335.png" alt="image-20190627171053335"></p>
<p>因为这里的 T 是不存在的。不存在？咋不存在，刚才不是在 Shop 这个接口里面都写了吗？怎么还是不存在？为什么呀。不存在？人家都是那么用 T 这个关键字，人家都不错，我错了？冷静下来想想，Shop 接口中那个 T 是用 <code>&lt;&gt;</code> 包裹着然后紧跟着接口名，我也试试。</p>
<pre><code class="language-java">public interface Repairableable&lt;T&gt; extends Shop&lt;T&gt;{

}
</code></pre>
<p>哎，对了，不报错了，这是什么原因？</p>
<p>首先，T 不是一个关键字，不是因为 T 才让一个借口变成泛型接口，它只是一个符号，重要的是包裹着 T 的 <code>&lt;&gt;</code>你可以把 T 换成任何字符，比如 B，E，甚至是 String 这个单词，它只是一直对未知类型的指代。</p>
<p>其次，T 的作用范围仅仅只是当前类或是当前接口。</p>
<p>所以，我们在 Repairableable 这个接口名后再像 Shop 接口那样声明出 T 就行了。</p>
<blockquote>
<ol>
<li>当你用 String 作为泛型类型的指代，那与本类中用来表示字符串的 String 冲突时，需要把表示字符串的 String 类的包名进行指定。</li>
<li><code>Repairableable&lt;T&gt; extends Shop&lt;T&gt;</code> 这两个 T 虽然字符一样，但是表示意思不一样，前者表示这是一个<strong>类型参数</strong>是 T 的接口名是  Repairableable 的接口，后者表示的是，Shop 接口的类型参数的<strong>实际值</strong>是 T 的接口。</li>
</ol>
</blockquote>
<p>对了，我们常用的 HashMap 他是两个泛型参数，那个怎么去定义的呢？</p>
<pre><code class="language-java">public class HashMap&lt;K,V&gt;{
  public void put(K key, V value) {
  }
  
  public V get(Object key) {
      return v;
  }
}
</code></pre>
<blockquote>
<p>非 HashMap 源代码，经改动。</p>
</blockquote>
<p>来自己动手写一下。</p>
<p>现在有一家店不仅卖苹果，还卖手机卡，这手机卡，有移动、联通、电信这三家运营商，他到底买的哪家的呢？也不知道，也不清楚。</p>
<pre><code class="language-java">public class ChinaMobile {
}

public class ChinaTelecom {
}

public class ChinaUnicom {
}

public interface SimShop&lt;T, S&gt; extends Shop&lt;T&gt;  {
    S buySim(String name, String id);
}

public class SimAppleShop implements AppleSimShop&lt;Apple, ChinaMobile&gt; {
    @Override
    public ChinaMobile buySim(String name, String id) {
        return null;
    }

    @Override
    public Apple buy() {
        return null;
    }

    @Override
    public int back(Apple product) {
        return 0;
    }
}
</code></pre>
<p>哎，这样看起来是挺不错的哈，泛型挺好用的呀。不过在实现 SimShop 的时候，要是有人乱填，写了一个一个不是三家运营商的类怎么办？那系统不就报错了？</p>
<p>当然为了，应对这种情况，Java 给出了解决方法，在 SimShop 的接口声明上加上限制，具体是这样的：</p>
<pre><code class="language-java">public interface SimShop&lt;T, S extends Sim&gt; extends Shop&lt;T&gt;  {
    S buySim(String name, String id);
}
</code></pre>
<p>这样一来，在实现 SimShop 类时，填入的第二个类型参数必须是继承自 Sim 类或实现了 Sim 接口的类。这里的 extends 指的不是继承，而是限制其类型参数的 类型。如果需要限制多个内容，使用 &amp; 符合进行连接，但不能存在多个类，只能存在多个接口，因为 Java 不允许多继承。在多限制条件中，存在类，需要放在最左边。例如：</p>
<p><code>interface SimShop &lt;T, S extends View &amp; Sim &amp; Fruit &amp; Serializable&gt;</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例模式]]></title>
        <id>https://cherrylover.github.io/post/dan-li-mo-shi</id>
        <link href="https://cherrylover.github.io/post/dan-li-mo-shi">
        </link>
        <updated>2019-05-24T03:22:51.000Z</updated>
        <content type="html"><![CDATA[<p>本文题图：Photo by <a href="https://unsplash.com/photos/bcAh4wFCBUM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Angelo Caputo</a> on <a href="https://unsplash.com/search/photos/moon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
<blockquote>
<p>本文是设计模式系列中的第二篇，上一篇是 <a href="https://jiangjiwei.site/post/ze-ren-lian-mo-shi/">责任链模式</a></p>
</blockquote>
<p>在软件开发的过程中，总是会期待某一个对象在整个应用程序的生命周期中，仅存在一次，该怎么做，我们都知道，就是引入单例模式这个设计模式，让这个对象保持始终只会创建一次。单例模式也是有多种形式，来了解一下吧。</p>
<pre><code class="language-java">Tasker tasker = new Tasker(&quot;Test&quot;);
tasker.doTask();

public class Tasker {
    private String name;

    public Tasker(String name) {
        this.name = name;
    }

    public void doTask() {
        System.out.println(name);
    }
}
</code></pre>
<p>这就是一个很简单的，创建 Tasker 对象，然后调用一次 <code>doTask</code> 方法。这里，我们不能通过代码的方法对它进行限制全局只创建一次。那怎么样才可以呢？</p>
<p>首先，我们需要将构造方法的访问权限设置为 <code>private</code>，设置为 <code>private</code> 之后，由于外部不能访问构造方法也就不能进行多次调用构造方法获取对象了。</p>
<p>那设置了 private 之后，外面怎么获取 Tasker 对象呢？答案是通过在 Tasker 内部新建一个静态方法 getInstance，然后通过静态方法返回一个 Tasker 对象，由于 Tasker 的构造方法的访问权限是 private，所以在 Tasker 内部访问这个构造方法是没有问题的。</p>
<p>那么我们只需要在 getInstance 方法内部进行检查需要返回的对象是否为空，如果为空则通过调用构造方法进行声明一个 Tasker 对象，如果不为空直接返回。由于 getInstance 方法是静态方法，所以，我们需要在 Tasker 里还需要维护一个静态的 Taster 对象。</p>
<pre><code class="language-java">Tasker tasker = Tasker.getInstance();
tasker.doTask();

public class Tasker {
    private String name;
    private static Tasker sTasker;

    public static Tasker getInstance() {
        if (sTasker == null) {
            sTasker = new Tasker(&quot;Test&quot;);
        }
        return sTasker;
    }

    private Tasker(String name) {
        this.name = name;
    }

    public void doTask() {
        System.out.println(name);
    }
}
</code></pre>
<p>这样我们就能得到一个简单的单例对象。并且这种形式被称之为<strong>懒汉单例模式</strong>。</p>
<p>这样就行了吗？并不是，这些代码运行在多线程中，可能就会存在一种情况，当一个线程调用 getInstance 判断 sTasker 为空，正在进行调用 Tasker 的构造方法，又有一个线程进入，也判断 sTasker 为空，这样就再次会调用 Tasker 的构造方法，这就不能保证 Tasker 这个类在系统中的唯一性。那要怎么解决这个问题呢？</p>
<p>我们知道，为保证线程安全，Java 有一个关键字 synchronized，我们在调用构造方法的时候加上这个 synchronized 关键字，同时在 sTasker 前加上 volatile 关键字，就能保证调用构造方法的线程安全，就像下面这样。</p>
<pre><code class="language-java">private static volatile Tasker sTasker;

public static Tasker getInstance() {
    if (sTasker == null) {
        synchronized (Tasker.class) {
            sTasker = new Tasker(&quot;Test&quot;);
        }
    }
    return sTasker;
}
</code></pre>
<p>但是这个是真的能保证是线程安全吗？不见得，当两个线程（A、B）同时访问 getInstance 这个方法时，由于线程 A 获取到了 synchronized 的锁定状态并创建了 Tasker 对象，而当线程 B 获取到 synchronized 的访问状态时，由于 Tasker 已经在线程 A 进行了创建，此时的 sTasker 并不为空，不需要再次调用 构造方法进行获取一个新的实例，所以，应该在 synchronized 锁定的代码块中再加入一个判断 sTasker 是否为空。这种形式的单例模式，我们称之为<strong>双重检查锁定实现的懒汉式单例模式</strong>。</p>
<pre><code class="language-java">private static volatile Tasker sTasker;

public static Tasker getInstance() {
		if (sTasker == null) {
				synchronized (Tasker.class) {
						if (sTasker == null) {
								sTasker = new Tasker(&quot;Test&quot;);
						}
				}
		}
		return sTasker;
}
</code></pre>
<p>那我能不能在声明这个变量（sTasker）的时候，就直接调用其构造方法来进行初始化操作。这样不就既保证了当前类实例在系统中的唯一性也保证了线程安全吗？没错，这样也是单例模式的另一种实现方式，叫<strong>饿汉式单例模式</strong>。</p>
<pre><code class="language-java">private static Tasker sTasker = new Tasker(&quot;Test&quot;);

public static Tasker getInstance() {
    return sTasker;
}
</code></pre>
<p>不过，饿汉式单例在当前类加载到内存中的时候就进行了初始化操作，假设我们没有使用到 sTasker，那去创建这个 sTasker 对象就相当于是浪费了，浪费可耻。而且当我们在构造方法中初始化过多的资源信息时也会影响整个系统的加载时长。从资源的使用角度来看，饿汉式的单例模式是不如双重检查的懒汉式的单例模式的，但双重检查的懒汉式单例也有属于他自己的问题，假设我们在构造方法中初始化了较多的资源，由于引入了 synchronized，所以在 getInstance 时将导致系统性能受到一定的影响。</p>
<p>那就没有两全其美的方法吗？有的，这种方法被称之为 Initializtion Demand Holder (IoDH)。</p>
<p>在 Java 中，通过在实例类中增加一个静态的内部类，在内部类中创建单例对象，再通过单例类的 getInstance 返回实例供外部使用。</p>
<pre><code class="language-java">private static class Inner {
    private static final Tasker TASKER = new Tasker(&quot;Test&quot;);
}

public static Tasker getInstance() {
    return Inner.TASKER;
}
</code></pre>
<p>由于类加载时不会实例化 Tasker 对象，所以只在 调用 getInstance 方法时才会调用。而在调用 getInstance 时才进行加载 Inner 类并创建一个 Tasker 实例，由 JVM 保证了其线程安全。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[善用搜索]]></title>
        <id>https://cherrylover.github.io/post/shan-yong-sou-suo</id>
        <link href="https://cherrylover.github.io/post/shan-yong-sou-suo">
        </link>
        <updated>2019-05-19T11:13:59.000Z</updated>
        <summary type="html"><![CDATA[<p>我一直在用搜索引擎，只不过我以前也没有意识到会用搜索引擎有什么大不了的，无非就是搜索，输入关键词，然后点击搜索。大家不都是这么用的吗？直到我最近经历的一件事情。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我一直在用搜索引擎，只不过我以前也没有意识到会用搜索引擎有什么大不了的，无非就是搜索，输入关键词，然后点击搜索。大家不都是这么用的吗？直到我最近经历的一件事情。</p>
 <!-- more --> 
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/20190519132136.png" alt=""></p>
<p>这个图里面的红框框柱的字，是一个提示文字，同样的工具上，别人的有这个提示文字，我没有，而且我还想要有怎么办呢？其实这无非就是一个设置而已，把设置打开就能显示。但关键是，在众多设置选项中，我怎么知道是哪一个设置选项呢？</p>
<p>方法有两个其一是找人问，其二是问搜索引擎。这里要说明一下，问人我可以直接把图发给对方甚至是发一个群里都行，事实上，我也这么做了。不过不是所有人都在等着你抛出问题，然后去给你解答的，很有可能你等了很久都没人回复，可能因为不知道，可能因为没看到，所以时间不受控制，有可能等正确答案到你手中的时候，已经过去一天了。第二种方法则不会出现这种情况，除非你家网不行，或者你问题描述的不够准确。不然的话，百度或是谷歌应该都能在 1 分钟之内给你答复。</p>
<p>我苦于不知道该怎么准确的描述出这个问题，我就在群里发起了提问，不到三分钟，一位朋友就回答了，可是并没有解决我的问题，我开始尝试着向搜索引擎寻求帮助，终于经过<strong>更改一次关键词</strong>，以及<strong>查阅两篇搜索结果</strong>之后，找到了正确处理的方法，这个时候另一位群友出来帮我解决了这个问题。虽然我已经通过搜索引擎解决了这个问题，但还是向他表示了感谢。</p>
<p>在这个事件中，看起来解决问题的两种方法话费的时间是一样的，但只是我足够幸运的遇上了及时回答的群友，而更可靠的则是几乎不会不理你的搜索引擎。</p>
<p>不过，在日常生活中，我也遇到过同样是使用搜索引擎，两个人搜索出来的结果几乎没有相同的，抛开搜索引擎根据你的历史记录而产生的偏好搜索，更为关键是你输入的关键词。在上面那个案例中，我更改了一次关键字，是因为第一次输入的关键词，我在没有点开搜索结果，仅靠每个搜索结果的标题就得出这些结果不可信的答案。于是，我更改了关键词。</p>
<p>事实上，针对于搜索引擎，我们应该做到尽量的减少关键词的长度，学会将具体的问题进行概括，萃取出关键词，这样能更为准确的得到搜索结果。</p>
<blockquote>
<p>谷歌和百度的搜索内容都是有长度限制的。</p>
<p>当你明确的知道搜索结果，比如搜一篇名为，实用工具Wox 的文章，你就能在搜索结果的第一条得到你想要的答案。</p>
</blockquote>
<p>有些时候，搜索引擎的搜索结果并不是那么好，我们自己可能有一个心里的预设，觉得知乎上，或是 stackoverflow 上可能会有答案，但直接这些网站的搜索真的很不好用，怎么办？没关系，搜索引擎考虑到了这个事情，所以有个关键词，site，具体使用就是，在你的关键词后面输入 <code>空格site:网站域名</code>。试试复制下面的文字，进行搜索，搜索出来的所有结果都是来自知乎。</p>
<blockquote>
<p>快闪 PPT site:zhihu.com</p>
</blockquote>
<p>如果记不住的这样的使用方式的话，百度还可以通过设置进行，点击下图中的红色选中区域，你就能发现，来自搜索引擎支持的多种搜索技巧，包括出现时间，搜索结果类型，以及查询站点。而 <code>site:zhihu.com</code> 就是利用了设置查询站点。</p>
<p><img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/20190519182103.png" alt=""></p>
<p>看了这个之后你就可以通过使用关键词加站点的方式找到知乎上关于如果高效使用搜索引擎的方法，来学习更多关于搜索引擎的小技巧。</p>
<p>本文题图：Photo by <a href="https://unsplash.com/photos/I_LgQ8JZFGE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">João Silas</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[For Free]]></title>
        <id>https://cherrylover.github.io/post/for-free</id>
        <link href="https://cherrylover.github.io/post/for-free">
        </link>
        <updated>2019-05-13T15:50:27.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>免费的永远是最贵的。</p>
</blockquote>
<p>这句话最早是马云在一个节目上说出来的，那时候的我还是一个连大学校门都不知道朝哪的高中生。当时只觉得呵呵，有钱人就是不一样，非得自己花钱吗？直到我体会到他所说的真正含义。</p>
<p>从我听说这句话，到写下这篇文章，也差不多有几年的时间了，这几年的时间，我慢慢的进行了转变。</p>
<p>印象跟感触最深的是两件事。先说第一件，我帮一个朋友翻译文章。他给了我一篇 PDF 格式的文章，里面的格式不太好，我转成了 Word 然后做了重新排版，想着直接丢到谷歌翻译上不就行了，毕竟以前也做过这个。还是挺喜欢谷歌翻译的，翻译出来之后，我尝试进行全选复制，然后发现字体样式实在是难搞。搞了一会之后，我在想，谷歌是这样的，我去看看国内的平台是怎么做的。</p>
<p>我就去了有道翻译，试着把原文档传上去了，然后惊奇的发现，整体的格式，以及中英文对照，做的都很不错，而且很贴心的给了一个下载翻译后的文档的功能，我点击上去发现，需要登录，然后付款 5 元才能下载。</p>
<p>对比使用谷歌翻译的一步步操作，对于用户来说，我只要你帮我解决问题即可。谷歌虽然也能解决问题，但是却附带着给我带来了一些我本不需要考虑的问题。这一点体验真的不太好了。比如当我可能时间不太充裕，着急要结果，我可能就会去花那个钱翻译一下，而不会使用谷歌翻译，虽然我日常使用都是用谷歌翻译，但也不太会在这件事情上偏心。</p>
<p>第二件事情，是关于我个人网站的图床。图床就是一个网络上用来存放图片的地方，比如，你把一张图片放在微博上，然后拿到那个图片的链接，你就随意的使用了，不用担心占用自己的空间。事实上，我最早用的就是微博的图床，可是，我总担心会出什么问题，我就注册了七牛，然后实名认证送空间，也能好好的用，直到有一天，不能好好用了，但是，我可以做一些认证设置(添加自定义域名，域名备案等等)然后继续使用，我也去做了，可是这个过程，我直到现在也没完全结束，而且中间还花 100+ 元。</p>
<p>最后，我放弃了，拥抱了阿里云，在阿里云花钱开了存储服务，然后一直在用，其实用来阿里云上的钱也不多，之前，粗略估计一下之前花在设置七牛云上的 100 多如果老老实实用阿里云的图片存储服务的话，估计能用一年多。这中间，我既花费了时间（至少有一个下午的时间花在研究备案，域名这些问题上），又搭上钱。结果……</p>
<p>我弄完阿里云之后，我就想到了，其实免费，说是免费，只是代价不是金钱，而且其他东西，可能是时间，精力，甚至是中国人讲的人情。而这些东西恰恰都是金钱所不能直接等价代换的。可能在免费，省去了你的金钱，可是你在其他方面的支出远远超过其所具有的金钱的价值。</p>
<p>最后，对象看到我在找本文题图，说为什么不放我的照片，然后我就放了我对象的照片（今天的题图也是她之前拍的）。<br>
<img src="https://monster-image-backup.oss-cn-shanghai.aliyuncs.com/picgo/UNADJUSTEDNONRAW_thumb_19d.jpg" alt="我对象"></p>
]]></content>
    </entry>
</feed>