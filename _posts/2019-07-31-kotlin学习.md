---
layout:     post  
title:      kotlin学习 
subtitle:   kotlin
date:       2019-07-31
author:     小卷子
header-img: img/tag-bg.jpg
catalog: true
tags:
    - 标签
---



[TOC]







##数据类型

### string的比较,== 和equals()

java比较字符串的内存地址用==，kotlin用===

kotlin中的== 和equals()是完全相同的

~~~java
s1 == s2;//相当于java中的equals()
s1 === s2;//相当于java中的==
~~~



### 字符串模板

可以在代码中声明一个变量，在变量前用$修饰，就变成了直接引用该对象。

~~~kotlin
val a = 10
val s = "a = $a" //打印结果为a = 10

val s = "Hello World"
println("s.length=${s.length}")
~~~



### var、val和const

**var：** var是一个可变变量，这是一个可以通过重新分配来更改为另一个值的变量。这种声明变量的方式和Java中声明变量的方式一样。
**val:** val是一个只读变量，这种声明变量的方式相当于java中的final变量。一个val创建的时候必须初始化，因为以后不能被改变。



一个**var**会对应生成两个方法,即getter和setter方法

~~~java
   var title: String? = null
~~~

生成的字节码会包含如下的两个方法和一个backing field

~~~java
    private static String title;
    @Nullable
    public static final String getTitle() {
        return title;
    }

    public static final void setTitle(@Nullable String title) {
        title = title;
    }
~~~



而**val**只会生成一个对应的get方法

~~~java
 val id: Long = 1L
~~~

生成的字节码会包含类似这样的方法

~~~java
   private static final long id = 1L;
    public static final long getId() {
        return id;
    }
~~~



`val定义常量的坑` val并不是真正的常量

通过val定义的变量，只有get方法，没有set方法，所以只能读不能写。
但是其get方法可以复写，从而造成val定义的变量，有可能会发生值变化，情况下面的例子：

~~~java
 val A : Int 
    get()  {
        val rand = Random(System.currentTimeMillis())
        return rand.nextInt()
    }
~~~

val定义的常量A的get()方法被复写，每次调用常量A都会返回一个随机数，所以不能保证常量A的值不变。



const:

const修饰的val变量相当于java中 `static final`是真正意义上的java常量

const关键有以下特点：

- 只能修改val常量。
- const只能修饰顶级属性（位于代码文件的最外部，意思是在结构上常量不属于任何的类，而是属于文件）

~~~java
const val userName: String = "yeqiu"
const val password: String = "yeqiu"
~~~





### 转义字符

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5j0063p8oj30fs09l0t4.jpg)





### ”“”三个引号

使用三个引号(""")包括，内部没有转义，可以包含换行和任何其他文本。所有转义在三个引号中都会失效





### 类和对象

java中创建类

~~~java
				public class Animal {
  
		    private int age;
 		  	private boolean sex;
        private String name;

        public Animal(int age, boolean sex, String name) {
            this.age = age;
            this.sex = sex;
            this.name = name;
      		  }
    		}
~~~

创建一个cat继承Animal

```
				public class Cat extends Animal {

 				   public Cat(int age, boolean sex, String name) {
 				       super(age, sex, name);
				    }

				    public void eat(){
				        System.out.println("猫 调用eat()");
				    }
    
				}
```

在使用上

~~~java
   		 public static void main(String[] args) {
   		     Animal animal = new Cat(1,true,"cat");
   		     if (animal instanceof Cat){
 		           Cat cat= (Cat) animal;
 		           cat.eat();
		        }
		    }
~~~



这是一段很简单的java代码，创建了Animal类，又创建Cat继承Animal，Cat中新加了eat()方法，main()中创建了一个Cat并赋值给了Animal，这里是父类引用指向子类对象。然后又把Animal强转成Cat并调用eat()方法。



以下是kotlin的实现方式

~~~java
				//kotli中所有类默认都是final,可以用open解除
				//constructor是构造方法
				//创建对象时默认执行
				open class Person constructor(var name: String, var age: Int, var sex: String) {

				    init {
				        println("姓名：$name,年龄：$age,性别：$sex")
				    }
				}
~~~



~~~java
				class Coder(name: String, age: Int, sex: String) : Person(name, age, sex) {
 
 				   fun coding() {
 				       println("coding")
 				   }
				}
~~~

~~~java
				fun main(args: Array<String>) {

				    var person: Person = Coder("Android", 18, "男");
				    //相当于java的强转，如果转换失败会抛出异常
				    val coder = person as Coder
				    coder.coding()
				}
~~~





### null安全



~~~java
				public String getName(){
     		   if (true){
       		     return "name";
      		  }else{
      		      return null;
      		  }
    		}
~~~

这是一段很常见的java代码，getName返回一个string，但是也可能会返回null。所有在调用的时候一般都会做*Nullcheck*

~~~java
				fun getName():String{
  				  if (true){
 				       return "name"
				    }else{
				        return null
 				   }
				}
~~~

以上是getName() kotlin的写法，但是这么写在编辑器中会报错。因为方法返回一个string不能返回null，修改为

~~~java
				fun getName(): String? {
				    if (true){
        				return "name"
    				}else{
        				return null
				    }
				}
~~~

这时候编译就没问题了，但是和java的写法一样都会有null的问题。看看这种写法在用的时候会有什么不一样

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k6kvsv0sj30jy0h9dfy.jpg)

这里定义了两个getName()，第一个可能会返回null，第二个不会返回null。在main方法中调用。可以看到第一个在`println(name.length)`的时候报错了。错误如下图;

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k6mfx9y6j30hh01ujr8.jpg)

大概的意思就是name这个值可能会是null，用的时候要做判断。改成这样

~~~java
				fun main() {
 				   val name = getName()
 				   val name2 = getName2()
 				   if (name!=null){
  				      println(name.length)
 				   }
 				   println(name2.length)
 				   //if中的判断也可以简化成，意思就是如果name不是null就正常执行否则直接输出null
 				    println(name?.length)
      
				}
~~~



还有场景

~~~java
				String name = getName();
        if (name==null){
            return;
        }
~~~

这段也是很常见的，如果name是null直接返回，不在执行下面的代码。kontlin中也可以这么写，但是写完之后编辑器会提示你可以简化成这样

~~~java
				//如果name是null直接return
				val name = getName() ?: return;
~~~

再看这段代码

![原谅我的分号](http://ww3.sinaimg.cn/large/006tNc79ly1g5k6ynshhkj30f1056jr9.jpg)



这里没有对name字段做任何非null的判断，但是在println中并没有报错，因为上一句代码中已经说明如果name是null的话就return(原谅我的分号)



另一种情况

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k7dm1e85j30ah02imwz.jpg)

这里声明了一个可以为null的name，那在调用的时候编译器又会提示*Nullcheck*，但是我知道这里的name不是null，可以换成下面的写法

~~~java
				fun main() {
				    var name:String? = "aaa";
				    println(name!!.length)
				}
~~~

在变量前用!!表示对象非null，如果name真的是null的话同样也会抛出NullPointerException，慎用!!

~~~java
 		   //任何的对象都可能存在null的情况
 		  	val notNull: String = null;//编译器报错，notNull对象不能为null
 		  	val nullable: String? = null;//正确，String?表示可以为null
 		   	notNull.length //正确，notNull对象不可能为null可以直接使用
  		  nullable.length //编译器报错，nullable对象可能为null必须先做Nullcheck
  		  nullable!!.length //正确 开发者确认nullable不为null，但是仍有空指针风险，这是很危险的操作
  		  nullable?.length //正确 如果nullable是null直接会返回null并不调用length方法
~~~



最后总结一下，其实在实际开发中null是不可避免的。在ava的编辑器感觉不够重视NullPointerException,我刚工作的时候被null折磨的苦不堪言，甚至改过IDE生成get()的模板来自动生成非null对象。kotlin中同样无法避免null，但是开发时编辑器会自动提示null的安全判断，同时也简化了null的判断（写法上我还是感觉有点怪）,编译器也变得十分智能。其实这并不能叫null安全，只是编辑器强制开发者必须要做*Nullcheck*。





### 类型转换

java中的强转

~~~java
        //创建cat并赋值给animal
        Animal animal = new Cat(1,true,"小猫咪");
        //调用cat中eat方法,必须先进行强转
        if (animal instanceof Cat){
            //强转成cat
            ((Cat) animal).eat();
        }
~~~

kotlin

```java
		var person :Person = Coder("Android",18,"男");
		//is 相当于java中的 instanceof
		if (person is Coder){
		    person.coding()
		}
```

可以看到都需要做强转前的判断，但是kotlin在判断后就不需要在做强转的操作。if成立后编译器认为`person == Coder`

另一个场景

```java
		//这里java会直接报类型转换异常
		Animal animal = new Animal(1,true,"小猫咪");
		((Cat) animal).eat();
```

kotlin

~~~java
		var person: Person = Person("Android", 18, "男");
		(person as Coder).coding()
~~~

这里强转同样会异常，看另一种写法

```java
		//这里在强转的时候使用了as？表示如果强转失败将会等到null，那在调用coding方法的时候判断为null停止调用
		var person: Person = Person("Android", 18, "男");
		val coder: Coder? = person as? Coder
		coder?.coding()
```



### 关于？和！！

**"?"加在变量名后，系统在任何情况不会报它的空指针异常。**
**"!!"加在变量名后，如果对象为null，那么系统一定会报异常！**

**?**到底怎么用。
在声明对象时，把它跟在类名后面，表示这个类允许为null；
在调用对象时，把它跟在对象后面，表示如果为null程序直接返回null并不继续调用

~~~kotlin
    var coder: Coder? = null
    //如果coder == null,coding方法不会执行
    coder?.coding()
    //如果coder == null并不影响这句代码
    println(coder === null)
~~~



然而加上问号以后程序就万事大吉永远摆脱了NullPointerException的烦恼？我们再看下一段代码：

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k9jaus0kj30fh03g746.jpg)

报错信息

![](http://ww1.sinaimg.cn/large/006tNc79ly1g5k9kas1w2j30mj01cdfo.jpg)

大概的意思是 list?.size > 0可能会返回null，null无法跟int进行比较，建议改成`list?.size!! > 0` 

好，一旦改成了这样这里的list就是null那运行到list?.size必然会空指针。看来必须要加上if !=null的判断，

~~~java
    		if (list!=null){
     		    if (list?.size > 0){
     		       println("list的长度不是0")
     		   } 
   		 }
~~~

然后这样就和java一样，有些啰嗦。可以简化成下面这样

```java
				if (list?.size ?: 0 > 0) {
				    println("list的长度不是0")
				}
```

Kotlin提供了`对象A ?: 对象B`表达式，并且取消了Java中的`条件表达式 ? 表达式1 : 表达式2`这个三元表达式。

?:表示的意思是，当对象A值为null的时候，那么它就会返回后面的对象B。

拆开来看上面的代码 list?.size ?: 0 > 0

```java
				val list: ArrayList<String>? = null
				val size = list?.size ?: 0//仅仅在左边的表达式结果为空时才会计算?:后面的表达式
				if (size > 0) {
  				  println("list的长度不是0")
				}
```



关于?:

这个也不是Java中的三元运算符,kotlin中没有三元运算符，当对象A值为null的时候，那么它就会返回后面的对象B

```java
				var name:String = null?:"name"
```



### 区间Range

Range表示一个取之范围  

```java
				var intRange1: IntRange = 0..100;//包含0 和100
				var intRange2: IntRange = 0 until 100;//包含0 不包含100
				val intRange3: IntRange = 0..-1  //不存在
```

```
				// var intRange1: IntRange = 0..100;
        if (i >= 0 && i <= 100) {
        }

        // var intRange2: IntRange = 0 until 100;//包含0 不包含100
        if (i >= 0 && i < 100) {
        }

        // val intRange3: IntRange = 0..-1  //不存在 没有大于等于0同时还小于等于-1的数字
        if (i >= 0 && i <= -1) {
        }
```



### 数组Array

数组跟java差不多

```java
    var intArray: IntArray = intArrayOf(1, 2, 3, 4, 5)
    var personArray : Array<Person>  = arrayOf(Person("Android", 18, "男"))

    for (i in intArray) {
        println(i)
    }
```

注意：Array != list





## 程序结构

### 函数

函数的写法：必须要以fun关键字开头。标准的函数写法如下：

```java
fun 标准函数(参数:String):Unit{
    //函数体
}
```

Unit和java中的void一样，kotlin中如果返回值是Unit可以省略不写。

```java
fun main(args: Array<String>) {
    test("阿姆斯特朗回旋加速喷气式阿姆斯特朗炮")
    test1("阿姆斯特朗回旋加速喷气式阿姆斯特朗炮")
}

fun test(name: String) {
    println("hi,$name")

}
//单行函数可以直接省去大括号使用=链接 返回值即函数体的范围值
fun test1(name: String) =  println("hi,$name")
//返回两个参数的和  这里的返回值:Int可以省略不写
fun test(x: Int, y: Int): Int = x + y
```



匿名函数

~~~java
val name = fun (name: String) = println("hi,$name")
~~~



### Lambda表达式

lambad表达式其实就是匿名函数的一种写法

基本语法：

`{参数列表 -> 函数体}`函数体的最后一行是返回值

~~~java
val  sum = {a:Int,b:Int -> a+b}
~~~

调用

~~~java
    println(sum(1,2))
    println(sum.invoke(2,3))
    //这里sum小括号其实是一个运算符 相当于调用了invoke方法
~~~



lambad表达式也有类型

```java
/** A function that takes 0 arguments. */
public interface Function0<out R> : Function<R> {
    /** Invokes the function. */
    public operator fun invoke(): R
}
/** A function that takes 1 argument. */
public interface Function1<in P1, out R> : Function<R> {
    /** Invokes the function with the specified argument. */
    public operator fun invoke(p1: P1): R
}
/** A function that takes 2 arguments. */
public interface Function2<in P1, in P2, out R> : Function<R> {
    /** Invokes the function with the specified arguments. */
    public operator fun invoke(p1: P1, p2: P2): R
```

Function0,Function1,Function2就是类型

Function0 = 没有参数

Function1 = 1个参数



声明一个lambad类型的变量

~~~java
    //声明lambda表达式 类型是 接受两个int参数,返回int结果
    private val sum: (x: Int, y: Int) -> Int

    init {
        //声明之后必须要初始化 初始化就是定义lambda的实现
        //这里只是返回两个数的和
        sum = { x, y -> x + y }
    }
~~~





### 类成员

和java中的属性一样，成员变量，成员方法。

kotlin自动实现了成员变量的set和get方法，可以通过重写去实现

~~~java
class Test {
    //多个成员在变量后面重写get和set
    var a = 10
        //get和set必须进阶写在成员后面 get方法中返回要使用field,不能直接使用变量
      	//field只能在get set中使用
        get() {
            println("重新get方法")
            return field
        }
        set(value) {
            field = value
            println("重新seet方法")
        }

    var b: Int = 20
        get() = field
        set(value) {
            field = value
        }
}
~~~

val修饰的成员是没有set()的



延时初始化

```
var i: Int = 0;
//延时初始化
lateinit var s: String
//延时初始化val
val s1:String by lazy {
    //注意这个只会在使用时执行
    "s1"
}
```



**属性初始化**

**1.属性的初始化尽可能在构造方法中完成 init()**

**2.无法在构造方法中初始化，尝试降级为局部变量（这样的场景比较少）**

**3.var用lateinit延时初始化，val用lazy**

**4.可用类型的变量尽量不要直接用null赋值初始化**



### 分支表达式

分支表达式最基本的就是if语句,用法也和java中一样。

if 表达式也是有返回值的

~~~java
    val int = if (true) {
        0
    } else {
        1
    }
~~~

注意 上面这样的赋值操作分支必须要完善，最后一定要有else





### 中缀表达式

其实就是类似java中`int instanceof Integer`

中缀表达式可以用来自定义运算符，比如 在遍历数组的时候

~~~java
 for (string in strings)
~~~

这里的in就是中缀表达式



1.中缀表达式必须使用infix修饰函数

2.只能有一个参数

~~~java
infix fun String.has(name: String): Boolean {

    return true
}
~~~

~~~java
    val isHas = "北京" has "五道口"
~~~





### when表达式

when表达式可以看成是java中switch的加强版，更加简单暴力且支持任意类型

~~~java
    //按顺序往下执行 任意一条匹配执行后即break跳出
    //default用else代替
    val x = 100
    when (x) {

        0, 1 -> println(" x = $x")

        10 -> println(" x = 10 ...")

        else -> println(" x = else ")
    }
~~~

同样 when表达式也有返回值





### 循环语句

循环语句和java基本一样，有for循环，while循环和do while循环。也有continue 和break关键字



### 异常捕获(try,catch,finally)

异常也和java中一样





### 具名参数，变长参数，默认参数

具名参数其实就是给实参附上形参 

```java
fun sum(a: Int, b: Int) {
    a + b
}
```

```java
sum(a = 1,b = 2)
sum(b = 2,a = 1)
```

在调用的时候指定参数的值，这样计算调换了a和b的位置，他们的值依然不变



变长参数，类似java中的可变参数。但是java中可变参数只能是方法参数的最后一个，kotlin中因为有具名参数的存在不限制可变参数的位置

~~~java
fun test(vararg ints:Int,string: String){
    //doSomething
}
~~~

~~~java
test(1,2,3,string ="test")
~~~



默认参数

给函数的参数设置默认值，如果调用者没有传递参数就使用默认值

~~~java
fun test(double: Double, vararg ints: Int, string: String = "test"){
    //string 有默认值 外界不传会使用默认值
    
    //doSomething
}
~~~

~~~java
test(0.1,1,2) //调用的时候没有传递string 如果string不是在最后一个，要使用具名参数来指定其他参数
~~~



## 面向对象



###  面向对象-抽象类与接口（abstract,interface）



### 继承



### 类及其成员的可见性（private,protected,internal,public）



### object



### 伴生对象与静态成员



### 方法重载与默认参数



### 扩展成员



### 属性代理



### 数据类



### 内部类(this@Outter,this@Inner)



### 枚举（enum）



### 密封类(sealed Class)



## 高阶函数



### 高阶函数的基本概念



### 常见高阶函数



### 尾递归优化 (tailrec)



### 闭包(函数式编程的福音)



### 函数复合（f(g(x)),infix）



### 柯里化（Currying）-函数调用链



### 偏函数





## 领域特定语言 DSL



### DSL 的基本概念



### 小案例：HTML DSL开发



### Gradle Kotlin 脚本编写





## 协程



### 协程入门



### 协程的启动模式



### 程的调度



### 协程的异常处理



### 协程的取消机制



### 协程的挂起原理分析



### 序列生成器



### 在 Android 中使用协程



### 协程总结





## 反射语法与库



### Kotlin中使用 Java 反射



### Kotlin 反射库的注意事项





## 泛型，型变，星投影



### 泛型的基本语法



### 泛型的实现机制



### 泛型的实现机制



### 型变



### 星投影





## Kotlin与 Java 混合开发



### 基本互操作



### SAM 转换



### 正则表达式



### 集合框架



### IO 操作



### 装箱和拆箱



### 注解处理器



### 混合开发总结





[forEach 跳出的问题](https://coding.imooc.com/learn/questiondetail/108331.html)

